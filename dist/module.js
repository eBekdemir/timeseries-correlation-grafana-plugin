/* [create-plugin] version: 6.4.3 */
          /* [create-plugin] plugin: enesbekdemir-analytics-panel@1.0.0 */
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
define(["@grafana/data","module","react"], (__WEBPACK_EXTERNAL_MODULE__grafana_data__, __WEBPACK_EXTERNAL_MODULE_amd_module__, __WEBPACK_EXTERNAL_MODULE_react__) => { return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./CorrelationPanel.tsx":
/*!******************************!*\
  !*** ./CorrelationPanel.tsx ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CorrelationPanel: () => (/* binding */ CorrelationPanel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_correlation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/correlation */ \"./utils/correlation.ts\");\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n    if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\n\n\nconst SERIES_COLORS = [\n    '#00eaff',\n    '#ff8c00',\n    '#9b59b6',\n    '#2ecc71'\n];\nconst getSeriesColor = (index)=>{\n    var _SERIES_COLORS_index;\n    return (_SERIES_COLORS_index = SERIES_COLORS[index]) !== null && _SERIES_COLORS_index !== void 0 ? _SERIES_COLORS_index : '#b3b3b3';\n};\nconst formatTimestamp = (value)=>{\n    if (value === null || value === undefined) {\n        return '';\n    }\n    let date = null;\n    if (value instanceof Date) {\n        date = value;\n    } else if (typeof value === 'number' || typeof value === 'string') {\n        date = new Date(value);\n    } else if (value && typeof value.valueOf === 'function') {\n        date = new Date(value.valueOf());\n    }\n    if (!date || Number.isNaN(date.getTime())) {\n        return String(value);\n    }\n    return date.toLocaleString();\n};\nconst getTimeValue = (value)=>{\n    if (value instanceof Date) {\n        return value.getTime();\n    }\n    const d = new Date(value);\n    const time = d.getTime();\n    if (!Number.isNaN(time)) {\n        return time;\n    }\n    if (value && typeof value.valueOf === 'function') {\n        const val = value.valueOf();\n        if (typeof val === 'number' && Number.isFinite(val)) {\n            return val;\n        }\n    }\n    const numeric = Number(value);\n    return Number.isNaN(numeric) ? 0 : numeric;\n};\nconst buildAxisTicks = (values, totalWidth)=>{\n    if (!values.length) {\n        return [];\n    }\n    const safeWidth = Math.max(totalWidth, 1);\n    const count = Math.min(5, values.length);\n    if (count <= 1) {\n        return [\n            {\n                x: 0,\n                label: formatTimestamp(values[0])\n            }\n        ];\n    }\n    const lastIndex = values.length - 1;\n    return Array.from({\n        length: count\n    }, (_, idx)=>{\n        const ratio = idx / (count - 1);\n        const targetIndex = Math.min(lastIndex, Math.round(ratio * lastIndex));\n        return {\n            x: ratio * safeWidth,\n            label: formatTimestamp(values[targetIndex])\n        };\n    });\n};\nconst buildValueTicks = (min, max, height, count = 5)=>{\n    if (!Number.isFinite(min) || !Number.isFinite(max) || height <= 0) {\n        return [];\n    }\n    if (min === max) {\n        return [\n            {\n                y: height / 2,\n                label: min.toLocaleString()\n            }\n        ];\n    }\n    const steps = Math.max(count, 2);\n    const range = max - min;\n    return Array.from({\n        length: steps\n    }, (_, idx)=>{\n        const ratio = idx / (steps - 1);\n        const value = max - ratio * range;\n        return {\n            y: ratio * height,\n            label: value.toLocaleString()\n        };\n    });\n};\nconst getSeriesRange = (values)=>{\n    const numericValues = values.filter((value)=>typeof value === 'number' && Number.isFinite(value));\n    if (!numericValues.length) {\n        return null;\n    }\n    return {\n        min: Math.min(...numericValues),\n        max: Math.max(...numericValues)\n    };\n};\nconst buildMetricPath = (values, chartWidth, plotHeight, min, max)=>{\n    if (!values.length) {\n        return '';\n    }\n    const denom = Math.max(values.length - 1, 1);\n    let path = '';\n    let hasOpenSegment = false;\n    const range = max - min;\n    values.forEach((value, idx)=>{\n        if (value === null || !Number.isFinite(value)) {\n            hasOpenSegment = false;\n            return;\n        }\n        const x = idx / denom * chartWidth;\n        const clamped = Math.min(Math.max(value, min), max);\n        const normalized = range === 0 ? 0.5 : (clamped - min) / range;\n        const y = (1 - normalized) * plotHeight;\n        path += `${hasOpenSegment ? ' L ' : 'M '}${x} ${y}`;\n        hasOpenSegment = true;\n    });\n    return path;\n};\nconst CorrelationPanel = ({ data, width, height, options })=>{\n    var _visibleSeries_, _visibleSeries_1;\n    const horizontalPadding = 20;\n    const verticalPadding = 20;\n    const chartWidth = Math.max(width - horizontalPadding, 10);\n    const [viewRange, setViewRange] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        0,\n        1\n    ]);\n    const [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        start: null,\n        end: null,\n        width: chartWidth\n    });\n    const [isSelecting, setIsSelecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [hoverInfo, setHoverInfo] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [metricMode, setMetricMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('correlation');\n    const [topSeriesMode, setTopSeriesMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('relative');\n    const [tooltipSize, setTooltipSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        width: 0,\n        height: 0\n    });\n    const [chromeHeight, setChromeHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const chromeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const hoverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (hoverInfo && hoverRef.current) {\n            const rect = hoverRef.current.getBoundingClientRect();\n            setTooltipSize((prev)=>{\n                if (prev.width === rect.width && prev.height === rect.height) {\n                    return prev;\n                }\n                return {\n                    width: rect.width,\n                    height: rect.height\n                };\n            });\n        } else if (!hoverInfo && (tooltipSize.width !== 0 || tooltipSize.height !== 0)) {\n            setTooltipSize({\n                width: 0,\n                height: 0\n            });\n        }\n    }, [\n        hoverInfo,\n        tooltipSize.width,\n        tooltipSize.height\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!chromeRef.current) {\n            return;\n        }\n        const measure = ()=>{\n            if (!chromeRef.current) {\n                return;\n            }\n            const rect = chromeRef.current.getBoundingClientRect();\n            setChromeHeight(rect.height);\n        };\n        measure();\n        if (typeof ResizeObserver !== 'undefined') {\n            const observer = new ResizeObserver(()=>{\n                measure();\n            });\n            observer.observe(chromeRef.current);\n            return ()=>observer.disconnect();\n        }\n        return;\n    }, [\n        width,\n        height\n    ]);\n    /** -------------------------\n   * Extract ALL time and numeric fields\n   --------------------------*/ let timeField = null;\n    const numericFields = [];\n    for (const frame of data.series){\n        const t = frame.fields.find((f)=>f.type === 'time');\n        if (t && !timeField) {\n            timeField = t; // take the first timestamp field\n        }\n        const nums = frame.fields.filter((f)=>f.type === 'number');\n        numericFields.push(...nums);\n    }\n    if (!timeField) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, \"No time field found.\");\n    }\n    if (numericFields.length < 2) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, \"At least 2 numeric series are required.\");\n    }\n    let timestamps = timeField.values.toArray();\n    const firstTime = timestamps.length ? getTimeValue(timestamps[0]) : 0;\n    const lastTime = timestamps.length ? getTimeValue(timestamps[timestamps.length - 1]) : 0;\n    const isTimeDescending = timestamps.length > 1 && firstTime > lastTime;\n    if (isTimeDescending) {\n        timestamps = [\n            ...timestamps\n        ].reverse();\n    }\n    const series = numericFields.map((f)=>{\n        const values = f.values.toArray();\n        return {\n            name: f.name,\n            values: isTimeDescending ? values.slice().reverse() : values\n        };\n    });\n    /** -------------------------\n   * Compute correlation only for the\n   * first two numeric fields\n   --------------------------*/ const window = options.windowSize || 30;\n    const rawCorrelation = (0,_utils_correlation__WEBPACK_IMPORTED_MODULE_1__.slidingCorrelation)(series[0].values, series[1].values, window);\n    const smoothingRadius = Math.max(1, Math.floor(window / 8));\n    const correlation = (0,_utils_correlation__WEBPACK_IMPORTED_MODULE_1__.smoothSeries)(rawCorrelation, smoothingRadius);\n    const rawCointegration = (0,_utils_correlation__WEBPACK_IMPORTED_MODULE_1__.computeCointegrationZScore)(series[0].values, series[1].values, window);\n    const cointegration = (0,_utils_correlation__WEBPACK_IMPORTED_MODULE_1__.smoothSeries)(rawCointegration, smoothingRadius);\n    /** -------------------------\n   * Zoom helpers\n   --------------------------*/ const totalPoints = Math.max(timestamps.length - 1, 1);\n    const startIndex = Math.max(0, Math.floor(viewRange[0] * totalPoints));\n    const endIndex = Math.min(timestamps.length - 1, Math.ceil(viewRange[1] * totalPoints));\n    const selectionActive = selection.start !== null && selection.end !== null;\n    const normalize = (v, min, max, h)=>{\n        if (max === min) {\n            return h / 2;\n        }\n        return (1 - (v - min) / (max - min)) * h;\n    };\n    const availablePlotHeight = Math.max(height - chromeHeight - verticalPadding, 0);\n    let topHeight = availablePlotHeight * 0.62;\n    let bottomHeight = availablePlotHeight - topHeight;\n    if (availablePlotHeight >= 120 && topHeight < 60) {\n        topHeight = 60;\n        bottomHeight = Math.max(availablePlotHeight - topHeight, 0);\n    }\n    if (availablePlotHeight >= 120 && bottomHeight < 60) {\n        bottomHeight = 60;\n        topHeight = Math.max(availablePlotHeight - bottomHeight, 0);\n    }\n    const seriesPlotHeight = Math.max(topHeight, 0);\n    const maxAxisPadding = Math.max(bottomHeight - 20, 0);\n    const bottomAxisPadding = Math.min(Math.max(bottomHeight * 0.2, 24), maxAxisPadding); // reserve room for ticks\n    let corrPlotHeight = bottomHeight <= 0 ? 0 : Math.max(bottomHeight - bottomAxisPadding, 0);\n    corrPlotHeight = Math.min(corrPlotHeight, bottomHeight);\n    const clamp = (value, min, max)=>Math.min(Math.max(value, min), max);\n    const minViewSpan = timestamps.length ? 1 / Math.max(timestamps.length, 1) : 0.001;\n    const updateHoverState = (localX, localWidth, pointer)=>{\n        if (!timestamps.length || !pointer) {\n            return;\n        }\n        const ratioWithinView = localWidth <= 0 ? 0 : localX / localWidth;\n        const spanIndices = Math.max(endIndex - startIndex, 0);\n        const dataIndex = clamp(startIndex + Math.round(ratioWithinView * spanIndices), 0, timestamps.length - 1);\n        const timeValue = timestamps[dataIndex];\n        const seriesValuesAtPointer = series.map((s)=>({\n                name: s.name,\n                value: typeof s.values[dataIndex] === 'number' ? s.values[dataIndex] : null\n            }));\n        const correlationValue = dataIndex < correlation.length && typeof correlation[dataIndex] === 'number' ? correlation[dataIndex] : null;\n        const cointegrationValue = dataIndex < cointegration.length && typeof cointegration[dataIndex] === 'number' ? cointegration[dataIndex] : null;\n        setHoverInfo({\n            timeLabel: formatTimestamp(timeValue),\n            seriesValues: seriesValuesAtPointer,\n            metrics: {\n                correlation: correlationValue,\n                cointegration: cointegrationValue\n            },\n            pointer\n        });\n    };\n    const extractPointerData = (event)=>{\n        var _containerRef_current;\n        const bounds = event.currentTarget.getBoundingClientRect();\n        const localWidth = Math.max(bounds.width, 1);\n        const x = clamp(event.clientX - bounds.left, 0, localWidth);\n        const containerBounds = (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.getBoundingClientRect();\n        const referenceBounds = containerBounds !== null && containerBounds !== void 0 ? containerBounds : bounds;\n        const refWidth = Math.max(referenceBounds.width, 1);\n        const refHeight = Math.max(referenceBounds.height, 1);\n        const pointer = {\n            x: clamp(event.clientX - referenceBounds.left, 0, refWidth),\n            y: clamp(event.clientY - referenceBounds.top, 0, refHeight)\n        };\n        updateHoverState(x, localWidth, pointer);\n        return {\n            x,\n            localWidth\n        };\n    };\n    const handleMouseDown = (event)=>{\n        const { x, localWidth } = extractPointerData(event);\n        setSelection({\n            start: x,\n            end: x,\n            width: localWidth\n        });\n        setIsSelecting(true);\n    };\n    const handleMouseMove = (event)=>{\n        const { x, localWidth } = extractPointerData(event);\n        if (isSelecting) {\n            setSelection((sel)=>_object_spread_props(_object_spread({}, sel), {\n                    end: x,\n                    width: localWidth\n                }));\n        }\n    };\n    const finishSelection = ()=>{\n        if (!selectionActive) {\n            setSelection({\n                start: null,\n                end: null,\n                width: chartWidth\n            });\n            setIsSelecting(false);\n            return;\n        }\n        var _selection_end, _selection_start;\n        const span = Math.abs(((_selection_end = selection.end) !== null && _selection_end !== void 0 ? _selection_end : 0) - ((_selection_start = selection.start) !== null && _selection_start !== void 0 ? _selection_start : 0));\n        if (span < 4) {\n            // consider too small to zoom\n            setSelection({\n                start: null,\n                end: null,\n                width: chartWidth\n            });\n            setIsSelecting(false);\n            return;\n        }\n        const baseWidth = Math.max(selection.width, 1);\n        const startRatio = Math.min(selection.start, selection.end) / baseWidth;\n        const endRatio = Math.max(selection.start, selection.end) / baseWidth;\n        const currentSpan = Math.max(viewRange[1] - viewRange[0], Number.EPSILON);\n        const newStart = clamp(viewRange[0] + startRatio * currentSpan, 0, 1);\n        const newEnd = clamp(viewRange[0] + endRatio * currentSpan, 0, 1);\n        setViewRange([\n            newStart,\n            newEnd\n        ]);\n        setSelection({\n            start: null,\n            end: null,\n            width: baseWidth\n        });\n        setIsSelecting(false);\n    };\n    const handleMouseUp = ()=>{\n        finishSelection();\n    };\n    const handleMouseLeave = ()=>{\n        if (isSelecting) {\n            finishSelection();\n        }\n        setHoverInfo(null);\n    };\n    const applyZoom = (zoomFactor)=>{\n        const currentSpan = Math.max(viewRange[1] - viewRange[0], minViewSpan);\n        const newSpan = clamp(currentSpan * zoomFactor, minViewSpan, 1);\n        const center = (viewRange[0] + viewRange[1]) / 2;\n        let newStart = center - newSpan / 2;\n        let newEnd = center + newSpan / 2;\n        if (newStart < 0) {\n            newEnd = Math.min(1, newEnd - newStart);\n            newStart = 0;\n        }\n        if (newEnd > 1) {\n            newStart = Math.max(0, newStart - (newEnd - 1));\n            newEnd = 1;\n        }\n        setViewRange([\n            newStart,\n            newEnd\n        ]);\n    };\n    const handleZoomIn = ()=>{\n        applyZoom(0.6);\n    };\n    const handleZoomOut = ()=>{\n        applyZoom(1.5);\n    };\n    const resetZoom = ()=>{\n        setViewRange([\n            0,\n            1\n        ]);\n        setSelection({\n            start: null,\n            end: null,\n            width: chartWidth\n        });\n    };\n    const visibleSeries = series.map((s)=>{\n        const maxIndex = Math.max(s.values.length - 1, 0);\n        const start = Math.min(startIndex, maxIndex);\n        const end = Math.min(endIndex, maxIndex);\n        return _object_spread_props(_object_spread({}, s), {\n            visibleValues: s.values.slice(start, end + 1)\n        });\n    });\n    const combinedSeriesRange = (()=>{\n        const values = [];\n        for (const s of visibleSeries){\n            for (const value of s.visibleValues){\n                if (typeof value === 'number' && Number.isFinite(value)) {\n                    values.push(value);\n                }\n            }\n        }\n        if (!values.length) {\n            return null;\n        }\n        return {\n            min: Math.min(...values),\n            max: Math.max(...values)\n        };\n    })();\n    const normalizedCombinedRange = (()=>{\n        if (!combinedSeriesRange) {\n            return null;\n        }\n        if (combinedSeriesRange.min === combinedSeriesRange.max) {\n            const padding = Math.max(Math.abs(combinedSeriesRange.min) * 0.05, 1);\n            return {\n                min: combinedSeriesRange.min - padding,\n                max: combinedSeriesRange.max + padding\n            };\n        }\n        return combinedSeriesRange;\n    })();\n    const visibleCorrelation = (()=>{\n        if (!correlation.length) {\n            return [];\n        }\n        const start = Math.min(startIndex, correlation.length - 1);\n        const end = Math.min(endIndex, correlation.length - 1);\n        return correlation.slice(start, end + 1);\n    })();\n    const visibleCointegration = (()=>{\n        if (!cointegration.length) {\n            return [];\n        }\n        const start = Math.min(startIndex, cointegration.length - 1);\n        const end = Math.min(endIndex, cointegration.length - 1);\n        return cointegration.slice(start, end + 1);\n    })();\n    const metricSeries = metricMode === 'correlation' ? visibleCorrelation : visibleCointegration;\n    const metricRange = metricMode === 'correlation' ? {\n        min: -1,\n        max: 1\n    } : (()=>{\n        const range = getSeriesRange(metricSeries);\n        if (!range) {\n            return {\n                min: -5,\n                max: 5\n            };\n        }\n        const maxAbs = Math.max(Math.abs(range.min), Math.abs(range.max));\n        const padded = Math.max(maxAbs * 1.1, 1);\n        return {\n            min: -padded,\n            max: padded\n        };\n    })();\n    const metricPath = buildMetricPath(metricSeries, chartWidth, corrPlotHeight, metricRange.min, metricRange.max);\n    const visibleTimestamps = (()=>{\n        if (!timestamps.length) {\n            return [];\n        }\n        const maxIndex = Math.max(timestamps.length - 1, 0);\n        const start = Math.min(startIndex, maxIndex);\n        const end = Math.min(endIndex, maxIndex);\n        return timestamps.slice(start, end + 1);\n    })();\n    const timeAxisTicks = buildAxisTicks(visibleTimestamps, chartWidth);\n    var _visibleSeries__visibleValues;\n    const firstSeriesRange = getSeriesRange((_visibleSeries__visibleValues = (_visibleSeries_ = visibleSeries[0]) === null || _visibleSeries_ === void 0 ? void 0 : _visibleSeries_.visibleValues) !== null && _visibleSeries__visibleValues !== void 0 ? _visibleSeries__visibleValues : []);\n    var _visibleSeries__visibleValues1;\n    const secondSeriesRange = getSeriesRange((_visibleSeries__visibleValues1 = (_visibleSeries_1 = visibleSeries[1]) === null || _visibleSeries_1 === void 0 ? void 0 : _visibleSeries_1.visibleValues) !== null && _visibleSeries__visibleValues1 !== void 0 ? _visibleSeries__visibleValues1 : []);\n    const firstSeriesTicks = firstSeriesRange ? buildValueTicks(firstSeriesRange.min, firstSeriesRange.max, seriesPlotHeight) : [];\n    const secondSeriesTicks = secondSeriesRange ? buildValueTicks(secondSeriesRange.min, secondSeriesRange.max, seriesPlotHeight) : [];\n    const firstSeriesColor = getSeriesColor(0);\n    const secondSeriesColor = getSeriesColor(1);\n    const sharedAxisTicks = topSeriesMode === 'normal' && normalizedCombinedRange ? buildValueTicks(normalizedCombinedRange.min, normalizedCombinedRange.max, seriesPlotHeight) : [];\n    const metricAxisTicks = buildValueTicks(metricRange.min, metricRange.max, corrPlotHeight);\n    const zeroLineY = metricRange.max === metricRange.min ? corrPlotHeight / 2 : (1 - (0 - metricRange.min) / (metricRange.max - metricRange.min)) * corrPlotHeight;\n    const selectionX = selectionActive ? Math.min(selection.start, selection.end) : 0;\n    var _selection_end, _selection_start;\n    const selectionWidth = selectionActive ? Math.abs(((_selection_end = selection.end) !== null && _selection_end !== void 0 ? _selection_end : 0) - ((_selection_start = selection.start) !== null && _selection_start !== void 0 ? _selection_start : 0)) : 0;\n    const leftAxisX = 0;\n    const rightAxisX = Math.max(chartWidth - 1, 0);\n    const canZoomOut = !(viewRange[0] === 0 && viewRange[1] === 1);\n    const canZoomIn = viewRange[1] - viewRange[0] > minViewSpan * 1.2;\n    const zoomButtonStyle = {\n        padding: '4px 8px',\n        background: '#333',\n        color: '#fff',\n        border: '1px solid #555',\n        borderRadius: 4,\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        width: 32,\n        height: 32\n    };\n    const floatingToggleButtonStyle = {\n        position: 'absolute',\n        left: 8,\n        top: 8,\n        padding: '4px 10px',\n        background: 'rgba(51, 51, 51, 0.9)',\n        color: '#fff',\n        border: '1px solid #555',\n        borderRadius: 4,\n        cursor: 'pointer',\n        zIndex: 10,\n        fontSize: 11\n    };\n    const metricModeLabel = metricMode === 'correlation' ? 'Rolling correlation' : 'Cointegration z-score';\n    const tooltipPosition = (()=>{\n        if (!hoverInfo) {\n            return null;\n        }\n        const offset = 12;\n        const availableWidth = Math.max(width - 4, 0);\n        const availableHeight = Math.max(height - 4, 0);\n        const tooltipWidth = tooltipSize.width || 0;\n        const tooltipHeight = tooltipSize.height || 0;\n        let left = hoverInfo.pointer.x + offset;\n        let top = hoverInfo.pointer.y + offset;\n        if (left + tooltipWidth > availableWidth) {\n            left = hoverInfo.pointer.x - offset - tooltipWidth;\n        }\n        if (left < 0) {\n            left = 0;\n        }\n        if (top + tooltipHeight > availableHeight) {\n            top = hoverInfo.pointer.y - offset - tooltipHeight;\n        }\n        if (top < 0) {\n            top = 0;\n        }\n        return {\n            left,\n            top\n        };\n    })();\n    const activeMetricValue = hoverInfo === null ? null : metricMode === 'correlation' ? hoverInfo.metrics.correlation : hoverInfo.metrics.cointegration;\n    const dateLabelHeight = 16;\n    const dateLabelY = Math.max(corrPlotHeight + 12, bottomHeight - dateLabelHeight - 4);\n    const timeAxisLabelY = Math.max(corrPlotHeight + 6, Math.min(corrPlotHeight + 10, dateLabelY - 4));\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        ref: containerRef,\n        style: {\n            width,\n            height,\n            padding: 10,\n            position: 'relative',\n            boxSizing: 'border-box',\n            display: 'flex',\n            flexDirection: 'column',\n            gap: 8,\n            overflow: 'hidden'\n        }\n    }, hoverInfo && tooltipPosition && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        ref: hoverRef,\n        style: {\n            position: 'absolute',\n            left: tooltipPosition.left,\n            top: tooltipPosition.top,\n            background: 'rgba(0,0,0,0.9)',\n            color: '#fff',\n            padding: '8px 12px',\n            borderRadius: 4,\n            fontSize: 12,\n            pointerEvents: 'none',\n            zIndex: 1000,\n            border: '1px solid rgba(255,255,255,0.2)'\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, \"Time: \", hoverInfo.timeLabel), hoverInfo.seriesValues.map(({ name, value })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            key: name\n        }, name, \": \", value === null || value === undefined ? 'N/A' : value.toLocaleString())), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, metricModeLabel, \": \", activeMetricValue === null ? 'N/A' : activeMetricValue.toFixed(3))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        ref: chromeRef,\n        style: {\n            display: 'flex',\n            flexDirection: 'column',\n            gap: 8\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", {\n        style: {\n            color: '#ddd',\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            margin: 0\n        }\n    }, \"Enes Bekdemir - 2025502000 - Rolling Pearson Correlation: \", series[0].name, \" vs \", series[1].name, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        style: {\n            display: 'flex',\n            gap: 8\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        onClick: handleZoomOut,\n        disabled: !canZoomOut,\n        style: _object_spread_props(_object_spread({}, zoomButtonStyle), {\n            cursor: canZoomOut ? 'pointer' : 'not-allowed',\n            opacity: canZoomOut ? 1 : 0.4\n        }),\n        \"aria-label\": \"Zoom out\",\n        title: \"Zoom out\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", {\n        width: \"16\",\n        height: \"16\",\n        viewBox: \"0 0 16 16\",\n        \"aria-hidden\": \"true\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"circle\", {\n        cx: \"6.5\",\n        cy: \"6.5\",\n        r: \"4.5\",\n        stroke: \"currentColor\",\n        fill: \"none\",\n        strokeWidth: \"1.5\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: \"4\",\n        y1: \"6.5\",\n        x2: \"9\",\n        y2: \"6.5\",\n        stroke: \"currentColor\",\n        strokeWidth: \"1.5\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: \"9.5\",\n        y1: \"9.5\",\n        x2: \"13.5\",\n        y2: \"13.5\",\n        stroke: \"currentColor\",\n        strokeWidth: \"1.5\",\n        strokeLinecap: \"round\"\n    }))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        onClick: handleZoomIn,\n        disabled: !canZoomIn,\n        style: _object_spread_props(_object_spread({}, zoomButtonStyle), {\n            cursor: canZoomIn ? 'pointer' : 'not-allowed',\n            opacity: canZoomIn ? 1 : 0.4\n        }),\n        \"aria-label\": \"Zoom in\",\n        title: \"Zoom in\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", {\n        width: \"16\",\n        height: \"16\",\n        viewBox: \"0 0 16 16\",\n        \"aria-hidden\": \"true\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"circle\", {\n        cx: \"6.5\",\n        cy: \"6.5\",\n        r: \"4.5\",\n        stroke: \"currentColor\",\n        fill: \"none\",\n        strokeWidth: \"1.5\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: \"4\",\n        y1: \"6.5\",\n        x2: \"9\",\n        y2: \"6.5\",\n        stroke: \"currentColor\",\n        strokeWidth: \"1.5\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: \"6.5\",\n        y1: \"4\",\n        x2: \"6.5\",\n        y2: \"9\",\n        stroke: \"currentColor\",\n        strokeWidth: \"1.5\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: \"9.5\",\n        y1: \"9.5\",\n        x2: \"13.5\",\n        y2: \"13.5\",\n        stroke: \"currentColor\",\n        strokeWidth: \"1.5\",\n        strokeLinecap: \"round\"\n    }))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        onClick: resetZoom,\n        disabled: !canZoomOut,\n        style: {\n            padding: '4px 8px',\n            background: '#333',\n            color: '#fff',\n            border: '1px solid #555',\n            borderRadius: 4,\n            cursor: canZoomOut ? 'pointer' : 'not-allowed'\n        }\n    }, \"Reset zoom\"))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        style: {\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            gap: 16,\n            color: '#ddd',\n            flexWrap: 'wrap'\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        style: {\n            display: 'flex',\n            gap: 16,\n            flexWrap: 'wrap',\n            alignItems: 'center'\n        }\n    }, series.slice(0, 2).map((s, idx)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            key: `${s.name}-${idx}`,\n            style: {\n                display: 'flex',\n                alignItems: 'center',\n                gap: 6\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n            style: {\n                width: 12,\n                height: 12,\n                borderRadius: 2,\n                background: getSeriesColor(idx),\n                display: 'inline-block'\n            }\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", null, s.name)))))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        style: {\n            flex: 1,\n            minHeight: 0,\n            display: 'flex',\n            flexDirection: 'column',\n            gap: 8\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        style: {\n            position: 'relative',\n            flex: '0 0 auto',\n            height: topHeight\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        onClick: ()=>setTopSeriesMode(topSeriesMode === 'relative' ? 'normal' : 'relative'),\n        style: floatingToggleButtonStyle\n    }, topSeriesMode === 'relative' ? 'Relative values' : 'Real values'), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", {\n        width: chartWidth,\n        height: topHeight,\n        style: {\n            background: '#111',\n            cursor: 'crosshair',\n            display: 'block'\n        },\n        onMouseDown: handleMouseDown,\n        onMouseMove: handleMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: handleMouseLeave\n    }, visibleSeries.map((s, idx)=>{\n        const visibleValues = s.visibleValues.length ? s.visibleValues : [];\n        if (!visibleValues.length) {\n            return null;\n        }\n        const localRange = topSeriesMode === 'normal' && normalizedCombinedRange ? normalizedCombinedRange : (()=>{\n            const min = Math.min(...visibleValues);\n            const max = Math.max(...visibleValues);\n            if (min === max) {\n                const padding = Math.max(Math.abs(min) * 0.05, 1);\n                return {\n                    min: min - padding,\n                    max: max + padding\n                };\n            }\n            return {\n                min,\n                max\n            };\n        })();\n        const path = visibleValues.map((v, i)=>{\n            const denom = Math.max(visibleValues.length - 1, 1);\n            const x = i / denom * chartWidth;\n            const y = normalize(v, localRange.min, localRange.max, seriesPlotHeight);\n            return `${x},${y}`;\n        }).join(' L ');\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n            key: idx,\n            d: `M ${path}`,\n            stroke: getSeriesColor(idx),\n            fill: \"none\",\n            strokeWidth: idx <= 1 ? 2 : 1\n        });\n    }), selectionActive && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"rect\", {\n        x: selectionX,\n        y: 0,\n        width: selectionWidth,\n        height: seriesPlotHeight,\n        fill: \"rgba(255, 255, 255, 0.1)\",\n        stroke: \"#fff\",\n        strokeDasharray: \"4\"\n    }), topSeriesMode === 'relative' && firstSeriesTicks.length > 0 && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: leftAxisX,\n        y1: 0,\n        x2: leftAxisX,\n        y2: seriesPlotHeight,\n        stroke: \"#333\",\n        strokeWidth: 1\n    }), firstSeriesTicks.map((tick, idx)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", {\n            key: `left-value-axis-${idx}`\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n            x1: leftAxisX,\n            y1: tick.y,\n            x2: leftAxisX + 6,\n            y2: tick.y,\n            stroke: firstSeriesColor,\n            strokeWidth: 1\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"text\", {\n            x: leftAxisX + 8,\n            y: tick.y,\n            fill: firstSeriesColor,\n            fontSize: 10,\n            textAnchor: \"start\",\n            dominantBaseline: \"middle\"\n        }, tick.label)))), topSeriesMode === 'relative' && secondSeriesTicks.length > 0 && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: rightAxisX,\n        y1: 0,\n        x2: rightAxisX,\n        y2: seriesPlotHeight,\n        stroke: \"#333\",\n        strokeWidth: 1\n    }), secondSeriesTicks.map((tick, idx)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", {\n            key: `right-value-axis-${idx}`\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n            x1: rightAxisX - 6,\n            y1: tick.y,\n            x2: rightAxisX,\n            y2: tick.y,\n            stroke: secondSeriesColor,\n            strokeWidth: 1\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"text\", {\n            x: rightAxisX - 8,\n            y: tick.y,\n            fill: secondSeriesColor,\n            fontSize: 10,\n            textAnchor: \"end\",\n            dominantBaseline: \"middle\"\n        }, tick.label)))), topSeriesMode === 'normal' && sharedAxisTicks.length > 0 && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: rightAxisX,\n        y1: 0,\n        x2: rightAxisX,\n        y2: seriesPlotHeight,\n        stroke: \"#333\",\n        strokeWidth: 1\n    }), sharedAxisTicks.map((tick, idx)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", {\n            key: `shared-value-axis-${idx}`\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n            x1: rightAxisX - 6,\n            y1: tick.y,\n            x2: rightAxisX,\n            y2: tick.y,\n            stroke: \"#bbb\",\n            strokeWidth: 1\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"text\", {\n            x: rightAxisX - 8,\n            y: tick.y,\n            fill: \"#bbb\",\n            fontSize: 10,\n            textAnchor: \"end\",\n            dominantBaseline: \"middle\"\n        }, tick.label)))))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        style: {\n            position: 'relative',\n            flex: '0 0 auto',\n            height: bottomHeight\n        },\n        onMouseLeave: handleMouseLeave\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        onClick: ()=>setMetricMode(metricMode === 'correlation' ? 'cointegration' : 'correlation'),\n        style: floatingToggleButtonStyle\n    }, metricModeLabel), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", {\n        width: chartWidth,\n        height: bottomHeight,\n        style: {\n            background: '#222',\n            cursor: 'crosshair',\n            display: 'block'\n        },\n        onMouseDown: handleMouseDown,\n        onMouseMove: handleMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseEnter: handleMouseMove\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"defs\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"clipPath\", {\n        id: \"metricClipPath\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"rect\", {\n        x: 0,\n        y: 0,\n        width: chartWidth,\n        height: corrPlotHeight\n    }))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"rect\", {\n        x: 0,\n        y: 0,\n        width: chartWidth,\n        height: corrPlotHeight,\n        fill: \"#222\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: 0,\n        y1: zeroLineY,\n        x2: chartWidth,\n        y2: zeroLineY,\n        stroke: \"#666\",\n        strokeDasharray: \"4\",\n        strokeWidth: 1\n    }), metricPath && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", {\n        clipPath: \"url(#metricClipPath)\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"path\", {\n        d: metricPath,\n        stroke: \"#60cfff\",\n        strokeWidth: 2,\n        fill: \"none\"\n    })), selectionActive && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"rect\", {\n        x: selectionX,\n        y: 0,\n        width: selectionWidth,\n        height: corrPlotHeight,\n        fill: \"rgba(255, 255, 255, 0.08)\",\n        stroke: \"#fff\",\n        strokeDasharray: \"4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: rightAxisX,\n        y1: 0,\n        x2: rightAxisX,\n        y2: corrPlotHeight,\n        stroke: \"#333\",\n        strokeWidth: 1\n    }), metricAxisTicks.map((tick, idx)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", {\n            key: `corr-value-axis-${idx}`\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n            x1: rightAxisX - 6,\n            y1: tick.y,\n            x2: rightAxisX,\n            y2: tick.y,\n            stroke: \"#555\",\n            strokeWidth: 1\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"text\", {\n            x: rightAxisX - 8,\n            y: tick.y,\n            fill: \"#bbb\",\n            fontSize: 10,\n            textAnchor: \"end\",\n            dominantBaseline: \"middle\"\n        }, tick.label))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n        x1: 0,\n        y1: corrPlotHeight,\n        x2: chartWidth,\n        y2: corrPlotHeight,\n        stroke: \"#333\",\n        strokeWidth: 1\n    }), timeAxisTicks.map((tick, idx)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", {\n            key: `corr-axis-${idx}`\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"line\", {\n            x1: tick.x,\n            y1: corrPlotHeight,\n            x2: tick.x,\n            y2: corrPlotHeight + 6,\n            stroke: \"#555\",\n            strokeWidth: 1\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"text\", {\n            x: tick.x,\n            y: timeAxisLabelY,\n            fill: \"#bbb\",\n            fontSize: 10,\n            textAnchor: \"middle\",\n            dominantBaseline: \"hanging\"\n        }, tick.label)))))));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUI7V0FFaEJILEtBQUtoUSxLQUFLO0FBUzdCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmVzYmVrZGVtaXItYW5hbHl0aWNzLXBhbmVsLy4vQ29ycmVsYXRpb25QYW5lbC50c3g/MTRmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUGFuZWxQcm9wcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgY29tcHV0ZUNvaW50ZWdyYXRpb25aU2NvcmUsIHNsaWRpbmdDb3JyZWxhdGlvbiwgc21vb3RoU2VyaWVzIH0gZnJvbSAnLi91dGlscy9jb3JyZWxhdGlvbic7XG5cblxuY29uc3QgU0VSSUVTX0NPTE9SUyA9IFsnIzAwZWFmZicsICcjZmY4YzAwJywgJyM5YjU5YjYnLCAnIzJlY2M3MSddO1xuXG5jb25zdCBnZXRTZXJpZXNDb2xvciA9IChpbmRleDogbnVtYmVyKSA9PiBTRVJJRVNfQ09MT1JTW2luZGV4XSA/PyAnI2IzYjNiMyc7XG5cbmNvbnN0IGZvcm1hdFRpbWVzdGFtcCA9ICh2YWx1ZTogYW55KSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgbGV0IGRhdGU6IERhdGUgfCBudWxsID0gbnVsbDtcblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgZGF0ZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkYXRlID0gbmV3IERhdGUodmFsdWUudmFsdWVPZigpKTtcbiAgfVxuXG4gIGlmICghZGF0ZSB8fCBOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gZGF0ZS50b0xvY2FsZVN0cmluZygpO1xufTtcblxuY29uc3QgZ2V0VGltZVZhbHVlID0gKHZhbHVlOiBhbnkpID0+IHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XG4gIH1cblxuICBjb25zdCBkID0gbmV3IERhdGUodmFsdWUpO1xuICBjb25zdCB0aW1lID0gZC5nZXRUaW1lKCk7XG4gIGlmICghTnVtYmVyLmlzTmFOKHRpbWUpKSB7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cblxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB2YWwgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZSh2YWwpKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG51bWVyaWMgPSBOdW1iZXIodmFsdWUpO1xuICByZXR1cm4gTnVtYmVyLmlzTmFOKG51bWVyaWMpID8gMCA6IG51bWVyaWM7XG59O1xuXG5jb25zdCBidWlsZEF4aXNUaWNrcyA9ICh2YWx1ZXM6IGFueVtdLCB0b3RhbFdpZHRoOiBudW1iZXIpID0+IHtcbiAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3Qgc2FmZVdpZHRoID0gTWF0aC5tYXgodG90YWxXaWR0aCwgMSk7XG4gIGNvbnN0IGNvdW50ID0gTWF0aC5taW4oNSwgdmFsdWVzLmxlbmd0aCk7XG5cbiAgaWYgKGNvdW50IDw9IDEpIHtcbiAgICByZXR1cm4gW3sgeDogMCwgbGFiZWw6IGZvcm1hdFRpbWVzdGFtcCh2YWx1ZXNbMF0pIH1dO1xuICB9XG5cbiAgY29uc3QgbGFzdEluZGV4ID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb3VudCB9LCAoXywgaWR4KSA9PiB7XG4gICAgY29uc3QgcmF0aW8gPSBpZHggLyAoY291bnQgLSAxKTtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IE1hdGgubWluKGxhc3RJbmRleCwgTWF0aC5yb3VuZChyYXRpbyAqIGxhc3RJbmRleCkpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiByYXRpbyAqIHNhZmVXaWR0aCxcbiAgICAgIGxhYmVsOiBmb3JtYXRUaW1lc3RhbXAodmFsdWVzW3RhcmdldEluZGV4XSlcbiAgICB9O1xuICB9KTtcbn07XG5cbmNvbnN0IGJ1aWxkVmFsdWVUaWNrcyA9IChtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBjb3VudCA9IDUpID0+IHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWluKSB8fCAhTnVtYmVyLmlzRmluaXRlKG1heCkgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAobWluID09PSBtYXgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB5OiBoZWlnaHQgLyAyLFxuICAgICAgICBsYWJlbDogbWluLnRvTG9jYWxlU3RyaW5nKClcbiAgICAgIH1cbiAgICBdO1xuICB9XG5cbiAgY29uc3Qgc3RlcHMgPSBNYXRoLm1heChjb3VudCwgMik7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuXG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzdGVwcyB9LCAoXywgaWR4KSA9PiB7XG4gICAgY29uc3QgcmF0aW8gPSBpZHggLyAoc3RlcHMgLSAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IG1heCAtIHJhdGlvICogcmFuZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgIHk6IHJhdGlvICogaGVpZ2h0LFxuICAgICAgbGFiZWw6IHZhbHVlLnRvTG9jYWxlU3RyaW5nKClcbiAgICB9O1xuICB9KTtcbn07XG5cbmNvbnN0IGdldFNlcmllc1JhbmdlID0gKHZhbHVlczogQXJyYXk8bnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZD4pID0+IHtcbiAgY29uc3QgbnVtZXJpY1ZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoXG4gICAgKHZhbHVlKTogdmFsdWUgaXMgbnVtYmVyID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlKVxuICApO1xuXG4gIGlmICghbnVtZXJpY1ZhbHVlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBNYXRoLm1pbiguLi5udW1lcmljVmFsdWVzKSxcbiAgICBtYXg6IE1hdGgubWF4KC4uLm51bWVyaWNWYWx1ZXMpXG4gIH07XG59O1xuXG5jb25zdCBidWlsZE1ldHJpY1BhdGggPSAoXG4gIHZhbHVlczogQXJyYXk8bnVtYmVyIHwgbnVsbD4sXG4gIGNoYXJ0V2lkdGg6IG51bWJlcixcbiAgcGxvdEhlaWdodDogbnVtYmVyLFxuICBtaW46IG51bWJlcixcbiAgbWF4OiBudW1iZXJcbikgPT4ge1xuICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCBkZW5vbSA9IE1hdGgubWF4KHZhbHVlcy5sZW5ndGggLSAxLCAxKTtcbiAgbGV0IHBhdGggPSAnJztcbiAgbGV0IGhhc09wZW5TZWdtZW50ID0gZmFsc2U7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuXG4gIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaWR4KSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8ICFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICBoYXNPcGVuU2VnbWVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSAoaWR4IC8gZGVub20pICogY2hhcnRXaWR0aDtcbiAgICBjb25zdCBjbGFtcGVkID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHJhbmdlID09PSAwID8gMC41IDogKGNsYW1wZWQgLSBtaW4pIC8gcmFuZ2U7XG4gICAgY29uc3QgeSA9ICgxIC0gbm9ybWFsaXplZCkgKiBwbG90SGVpZ2h0O1xuICAgIHBhdGggKz0gYCR7aGFzT3BlblNlZ21lbnQgPyAnIEwgJyA6ICdNICd9JHt4fSAke3l9YDtcbiAgICBoYXNPcGVuU2VnbWVudCA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBwYXRoO1xufTtcblxudHlwZSBQYW5lbE9wdGlvbnMgPSB7XG4gIHdpbmRvd1NpemU/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgY29uc3QgQ29ycmVsYXRpb25QYW5lbDogUmVhY3QuRkM8UGFuZWxQcm9wczxQYW5lbE9wdGlvbnM+PiA9ICh7XG4gIGRhdGEsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIG9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgaG9yaXpvbnRhbFBhZGRpbmcgPSAyMDtcbiAgY29uc3QgdmVydGljYWxQYWRkaW5nID0gMjA7XG4gIGNvbnN0IGNoYXJ0V2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIGhvcml6b250YWxQYWRkaW5nLCAxMCk7XG4gIGNvbnN0IFt2aWV3UmFuZ2UsIHNldFZpZXdSYW5nZV0gPSB1c2VTdGF0ZTxbbnVtYmVyLCBudW1iZXJdPihbMCwgMV0pO1xuICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gdXNlU3RhdGU8eyBzdGFydDogbnVtYmVyIHwgbnVsbDsgZW5kOiBudW1iZXIgfCBudWxsOyB3aWR0aDogbnVtYmVyIH0+KHtcbiAgICBzdGFydDogbnVsbCxcbiAgICBlbmQ6IG51bGwsXG4gICAgd2lkdGg6IGNoYXJ0V2lkdGhcbiAgfSk7XG4gIGNvbnN0IFtpc1NlbGVjdGluZywgc2V0SXNTZWxlY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaG92ZXJJbmZvLCBzZXRIb3ZlckluZm9dID0gdXNlU3RhdGU8e1xuICAgIHRpbWVMYWJlbDogc3RyaW5nO1xuICAgIHNlcmllc1ZhbHVlczogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBudW1iZXIgfCBudWxsIH0+O1xuICAgIG1ldHJpY3M6IHsgY29ycmVsYXRpb246IG51bWJlciB8IG51bGw7IGNvaW50ZWdyYXRpb246IG51bWJlciB8IG51bGwgfTtcbiAgICBwb2ludGVyOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW21ldHJpY01vZGUsIHNldE1ldHJpY01vZGVdID0gdXNlU3RhdGU8J2NvcnJlbGF0aW9uJyB8ICdjb2ludGVncmF0aW9uJz4oJ2NvcnJlbGF0aW9uJyk7XG4gIGNvbnN0IFt0b3BTZXJpZXNNb2RlLCBzZXRUb3BTZXJpZXNNb2RlXSA9IHVzZVN0YXRlPCdyZWxhdGl2ZScgfCAnbm9ybWFsJz4oJ3JlbGF0aXZlJyk7XG4gIGNvbnN0IFt0b29sdGlwU2l6ZSwgc2V0VG9vbHRpcFNpemVdID0gdXNlU3RhdGUoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICBjb25zdCBbY2hyb21lSGVpZ2h0LCBzZXRDaHJvbWVIZWlnaHRdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjaHJvbWVSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgaG92ZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaG92ZXJJbmZvICYmIGhvdmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBob3ZlclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgc2V0VG9vbHRpcFNpemUocHJldiA9PiB7XG4gICAgICAgIGlmIChwcmV2LndpZHRoID09PSByZWN0LndpZHRoICYmIHByZXYuaGVpZ2h0ID09PSByZWN0LmhlaWdodCkge1xuICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHdpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0IH07XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFob3ZlckluZm8gJiYgKHRvb2x0aXBTaXplLndpZHRoICE9PSAwIHx8IHRvb2x0aXBTaXplLmhlaWdodCAhPT0gMCkpIHtcbiAgICAgIHNldFRvb2x0aXBTaXplKHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICB9XG4gIH0sIFtob3ZlckluZm8sIHRvb2x0aXBTaXplLndpZHRoLCB0b29sdGlwU2l6ZS5oZWlnaHRdKTtcblxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hyb21lUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZWFzdXJlID0gKCkgPT4ge1xuICAgICAgaWYgKCFjaHJvbWVSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWN0ID0gY2hyb21lUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBzZXRDaHJvbWVIZWlnaHQocmVjdC5oZWlnaHQpO1xuICAgIH07XG5cbiAgICBtZWFzdXJlKCk7XG5cbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBtZWFzdXJlKCk7XG4gICAgICB9KTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUoY2hyb21lUmVmLmN1cnJlbnQpO1xuICAgICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0sIFt3aWR0aCwgaGVpZ2h0XSk7XG5cbiAgLyoqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRXh0cmFjdCBBTEwgdGltZSBhbmQgbnVtZXJpYyBmaWVsZHNcbiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgbGV0IHRpbWVGaWVsZDogYW55ID0gbnVsbDtcbiAgY29uc3QgbnVtZXJpY0ZpZWxkczogYW55W10gPSBbXTtcblxuICBmb3IgKGNvbnN0IGZyYW1lIG9mIGRhdGEuc2VyaWVzKSB7XG4gICAgY29uc3QgdCA9IGZyYW1lLmZpZWxkcy5maW5kKGYgPT4gZi50eXBlID09PSAndGltZScpO1xuICAgIGlmICh0ICYmICF0aW1lRmllbGQpIHtcbiAgICAgIHRpbWVGaWVsZCA9IHQ7IC8vIHRha2UgdGhlIGZpcnN0IHRpbWVzdGFtcCBmaWVsZFxuICAgIH1cblxuICAgIGNvbnN0IG51bXMgPSBmcmFtZS5maWVsZHMuZmlsdGVyKGYgPT4gZi50eXBlID09PSAnbnVtYmVyJyk7XG4gICAgbnVtZXJpY0ZpZWxkcy5wdXNoKC4uLm51bXMpO1xuICB9XG5cbiAgaWYgKCF0aW1lRmllbGQpIHtcbiAgICByZXR1cm4gPGRpdj5ObyB0aW1lIGZpZWxkIGZvdW5kLjwvZGl2PjtcbiAgfVxuXG4gIGlmIChudW1lcmljRmllbGRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gPGRpdj5BdCBsZWFzdCAyIG51bWVyaWMgc2VyaWVzIGFyZSByZXF1aXJlZC48L2Rpdj47XG4gIH1cblxuICBsZXQgdGltZXN0YW1wcyA9IHRpbWVGaWVsZC52YWx1ZXMudG9BcnJheSgpO1xuICBjb25zdCBmaXJzdFRpbWUgPSB0aW1lc3RhbXBzLmxlbmd0aCA/IGdldFRpbWVWYWx1ZSh0aW1lc3RhbXBzWzBdKSA6IDA7XG4gIGNvbnN0IGxhc3RUaW1lID0gdGltZXN0YW1wcy5sZW5ndGggPyBnZXRUaW1lVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKSA6IDA7XG4gIGNvbnN0IGlzVGltZURlc2NlbmRpbmcgPSB0aW1lc3RhbXBzLmxlbmd0aCA+IDEgJiYgZmlyc3RUaW1lID4gbGFzdFRpbWU7XG4gIGlmIChpc1RpbWVEZXNjZW5kaW5nKSB7XG4gICAgdGltZXN0YW1wcyA9IFsuLi50aW1lc3RhbXBzXS5yZXZlcnNlKCk7XG4gIH1cblxuICB0eXBlIE51bWVyaWNTZXJpZXMgPSB7IG5hbWU6IHN0cmluZzsgdmFsdWVzOiBudW1iZXJbXSB9O1xuICBjb25zdCBzZXJpZXM6IE51bWVyaWNTZXJpZXNbXSA9IG51bWVyaWNGaWVsZHMubWFwKGYgPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IGYudmFsdWVzLnRvQXJyYXkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogZi5uYW1lLFxuICAgICAgdmFsdWVzOiBpc1RpbWVEZXNjZW5kaW5nID8gdmFsdWVzLnNsaWNlKCkucmV2ZXJzZSgpIDogdmFsdWVzXG4gICAgfTtcbiAgfSk7XG5cbiAgLyoqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29tcHV0ZSBjb3JyZWxhdGlvbiBvbmx5IGZvciB0aGVcbiAgICogZmlyc3QgdHdvIG51bWVyaWMgZmllbGRzXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIGNvbnN0IHdpbmRvdyA9IG9wdGlvbnMud2luZG93U2l6ZSB8fCAzMDtcbiAgY29uc3QgcmF3Q29ycmVsYXRpb24gPSBzbGlkaW5nQ29ycmVsYXRpb24oc2VyaWVzWzBdLnZhbHVlcywgc2VyaWVzWzFdLnZhbHVlcywgd2luZG93KTtcbiAgY29uc3Qgc21vb3RoaW5nUmFkaXVzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih3aW5kb3cgLyA4KSk7XG4gIGNvbnN0IGNvcnJlbGF0aW9uID0gc21vb3RoU2VyaWVzKHJhd0NvcnJlbGF0aW9uLCBzbW9vdGhpbmdSYWRpdXMpO1xuICBjb25zdCByYXdDb2ludGVncmF0aW9uID0gY29tcHV0ZUNvaW50ZWdyYXRpb25aU2NvcmUoc2VyaWVzWzBdLnZhbHVlcywgc2VyaWVzWzFdLnZhbHVlcywgd2luZG93KTtcbiAgY29uc3QgY29pbnRlZ3JhdGlvbiA9IHNtb290aFNlcmllcyhyYXdDb2ludGVncmF0aW9uLCBzbW9vdGhpbmdSYWRpdXMpO1xuXG4gIC8qKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFpvb20gaGVscGVyc1xuICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBjb25zdCB0b3RhbFBvaW50cyA9IE1hdGgubWF4KHRpbWVzdGFtcHMubGVuZ3RoIC0gMSwgMSk7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHZpZXdSYW5nZVswXSAqIHRvdGFsUG9pbnRzKSk7XG4gIGNvbnN0IGVuZEluZGV4ID0gTWF0aC5taW4odGltZXN0YW1wcy5sZW5ndGggLSAxLCBNYXRoLmNlaWwodmlld1JhbmdlWzFdICogdG90YWxQb2ludHMpKTtcblxuICBjb25zdCBzZWxlY3Rpb25BY3RpdmUgPSBzZWxlY3Rpb24uc3RhcnQgIT09IG51bGwgJiYgc2VsZWN0aW9uLmVuZCAhPT0gbnVsbDtcblxuICBjb25zdCBub3JtYWxpemUgPSAodjogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIGg6IG51bWJlcikgPT4ge1xuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgcmV0dXJuIGggLyAyO1xuICAgIH1cbiAgICByZXR1cm4gKDEgLSAodiAtIG1pbikgLyAobWF4IC0gbWluKSkgKiBoO1xuICB9O1xuXG4gIGNvbnN0IGF2YWlsYWJsZVBsb3RIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgLSBjaHJvbWVIZWlnaHQgLSB2ZXJ0aWNhbFBhZGRpbmcsIDApO1xuICBsZXQgdG9wSGVpZ2h0ID0gYXZhaWxhYmxlUGxvdEhlaWdodCAqIDAuNjI7XG4gIGxldCBib3R0b21IZWlnaHQgPSBhdmFpbGFibGVQbG90SGVpZ2h0IC0gdG9wSGVpZ2h0O1xuICBpZiAoYXZhaWxhYmxlUGxvdEhlaWdodCA+PSAxMjAgJiYgdG9wSGVpZ2h0IDwgNjApIHtcbiAgICB0b3BIZWlnaHQgPSA2MDtcbiAgICBib3R0b21IZWlnaHQgPSBNYXRoLm1heChhdmFpbGFibGVQbG90SGVpZ2h0IC0gdG9wSGVpZ2h0LCAwKTtcbiAgfVxuICBpZiAoYXZhaWxhYmxlUGxvdEhlaWdodCA+PSAxMjAgJiYgYm90dG9tSGVpZ2h0IDwgNjApIHtcbiAgICBib3R0b21IZWlnaHQgPSA2MDtcbiAgICB0b3BIZWlnaHQgPSBNYXRoLm1heChhdmFpbGFibGVQbG90SGVpZ2h0IC0gYm90dG9tSGVpZ2h0LCAwKTtcbiAgfVxuICBjb25zdCBzZXJpZXNQbG90SGVpZ2h0ID0gTWF0aC5tYXgodG9wSGVpZ2h0LCAwKTtcbiAgY29uc3QgbWF4QXhpc1BhZGRpbmcgPSBNYXRoLm1heChib3R0b21IZWlnaHQgLSAyMCwgMCk7XG4gIGNvbnN0IGJvdHRvbUF4aXNQYWRkaW5nID0gTWF0aC5taW4oTWF0aC5tYXgoYm90dG9tSGVpZ2h0ICogMC4yLCAyNCksIG1heEF4aXNQYWRkaW5nKTsgLy8gcmVzZXJ2ZSByb29tIGZvciB0aWNrc1xuICBsZXQgY29yclBsb3RIZWlnaHQgPSBib3R0b21IZWlnaHQgPD0gMCA/IDAgOiBNYXRoLm1heChib3R0b21IZWlnaHQgLSBib3R0b21BeGlzUGFkZGluZywgMCk7XG4gIGNvcnJQbG90SGVpZ2h0ID0gTWF0aC5taW4oY29yclBsb3RIZWlnaHQsIGJvdHRvbUhlaWdodCk7XG5cbiAgY29uc3QgY2xhbXAgPSAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcblxuICBjb25zdCBtaW5WaWV3U3BhbiA9IHRpbWVzdGFtcHMubGVuZ3RoID8gMSAvIE1hdGgubWF4KHRpbWVzdGFtcHMubGVuZ3RoLCAxKSA6IDAuMDAxO1xuXG4gIGNvbnN0IHVwZGF0ZUhvdmVyU3RhdGUgPSAobG9jYWxYOiBudW1iZXIsIGxvY2FsV2lkdGg6IG51bWJlciwgcG9pbnRlcjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbCkgPT4ge1xuICAgIGlmICghdGltZXN0YW1wcy5sZW5ndGggfHwgIXBvaW50ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmF0aW9XaXRoaW5WaWV3ID0gbG9jYWxXaWR0aCA8PSAwID8gMCA6IGxvY2FsWCAvIGxvY2FsV2lkdGg7XG4gICAgY29uc3Qgc3BhbkluZGljZXMgPSBNYXRoLm1heChlbmRJbmRleCAtIHN0YXJ0SW5kZXgsIDApO1xuICAgIGNvbnN0IGRhdGFJbmRleCA9IGNsYW1wKHN0YXJ0SW5kZXggKyBNYXRoLnJvdW5kKHJhdGlvV2l0aGluVmlldyAqIHNwYW5JbmRpY2VzKSwgMCwgdGltZXN0YW1wcy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCB0aW1lVmFsdWUgPSB0aW1lc3RhbXBzW2RhdGFJbmRleF07XG4gICAgY29uc3Qgc2VyaWVzVmFsdWVzQXRQb2ludGVyID0gc2VyaWVzLm1hcChzID0+ICh7XG4gICAgICBuYW1lOiBzLm5hbWUsXG4gICAgICB2YWx1ZTogdHlwZW9mIHMudmFsdWVzW2RhdGFJbmRleF0gPT09ICdudW1iZXInID8gcy52YWx1ZXNbZGF0YUluZGV4XSA6IG51bGxcbiAgICB9KSk7XG4gICAgY29uc3QgY29ycmVsYXRpb25WYWx1ZSA9XG4gICAgICBkYXRhSW5kZXggPCBjb3JyZWxhdGlvbi5sZW5ndGggJiYgdHlwZW9mIGNvcnJlbGF0aW9uW2RhdGFJbmRleF0gPT09ICdudW1iZXInXG4gICAgICAgID8gY29ycmVsYXRpb25bZGF0YUluZGV4XVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgY29pbnRlZ3JhdGlvblZhbHVlID1cbiAgICAgIGRhdGFJbmRleCA8IGNvaW50ZWdyYXRpb24ubGVuZ3RoICYmIHR5cGVvZiBjb2ludGVncmF0aW9uW2RhdGFJbmRleF0gPT09ICdudW1iZXInXG4gICAgICAgID8gY29pbnRlZ3JhdGlvbltkYXRhSW5kZXhdXG4gICAgICAgIDogbnVsbDtcbiAgICBzZXRIb3ZlckluZm8oe1xuICAgICAgdGltZUxhYmVsOiBmb3JtYXRUaW1lc3RhbXAodGltZVZhbHVlKSxcbiAgICAgIHNlcmllc1ZhbHVlczogc2VyaWVzVmFsdWVzQXRQb2ludGVyLFxuICAgICAgbWV0cmljczogeyBjb3JyZWxhdGlvbjogY29ycmVsYXRpb25WYWx1ZSwgY29pbnRlZ3JhdGlvbjogY29pbnRlZ3JhdGlvblZhbHVlIH0sXG4gICAgICBwb2ludGVyXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgZXh0cmFjdFBvaW50ZXJEYXRhID0gKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PFNWR1NWR0VsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgYm91bmRzID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBsb2NhbFdpZHRoID0gTWF0aC5tYXgoYm91bmRzLndpZHRoLCAxKTtcbiAgICBjb25zdCB4ID0gY2xhbXAoZXZlbnQuY2xpZW50WCAtIGJvdW5kcy5sZWZ0LCAwLCBsb2NhbFdpZHRoKTtcbiAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSBjb250YWluZXJSZWYuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcmVmZXJlbmNlQm91bmRzID0gY29udGFpbmVyQm91bmRzID8/IGJvdW5kcztcbiAgICBjb25zdCByZWZXaWR0aCA9IE1hdGgubWF4KHJlZmVyZW5jZUJvdW5kcy53aWR0aCwgMSk7XG4gICAgY29uc3QgcmVmSGVpZ2h0ID0gTWF0aC5tYXgocmVmZXJlbmNlQm91bmRzLmhlaWdodCwgMSk7XG4gICAgY29uc3QgcG9pbnRlciA9IHtcbiAgICAgIHg6IGNsYW1wKGV2ZW50LmNsaWVudFggLSByZWZlcmVuY2VCb3VuZHMubGVmdCwgMCwgcmVmV2lkdGgpLFxuICAgICAgeTogY2xhbXAoZXZlbnQuY2xpZW50WSAtIHJlZmVyZW5jZUJvdW5kcy50b3AsIDAsIHJlZkhlaWdodClcbiAgICB9O1xuICAgIHVwZGF0ZUhvdmVyU3RhdGUoeCwgbG9jYWxXaWR0aCwgcG9pbnRlcik7XG4gICAgcmV0dXJuIHsgeCwgbG9jYWxXaWR0aCB9O1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZU1vdXNlRG93biA9IChldmVudDogUmVhY3QuTW91c2VFdmVudDxTVkdTVkdFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgeCwgbG9jYWxXaWR0aCB9ID0gZXh0cmFjdFBvaW50ZXJEYXRhKGV2ZW50KTtcbiAgICBzZXRTZWxlY3Rpb24oeyBzdGFydDogeCwgZW5kOiB4LCB3aWR0aDogbG9jYWxXaWR0aCB9KTtcbiAgICBzZXRJc1NlbGVjdGluZyh0cnVlKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8U1ZHU1ZHRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IHgsIGxvY2FsV2lkdGggfSA9IGV4dHJhY3RQb2ludGVyRGF0YShldmVudCk7XG4gICAgaWYgKGlzU2VsZWN0aW5nKSB7XG4gICAgICBzZXRTZWxlY3Rpb24oc2VsID0+ICh7IC4uLnNlbCwgZW5kOiB4LCB3aWR0aDogbG9jYWxXaWR0aCB9KSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGZpbmlzaFNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoIXNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCwgd2lkdGg6IGNoYXJ0V2lkdGggfSk7XG4gICAgICBzZXRJc1NlbGVjdGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3BhbiA9IE1hdGguYWJzKChzZWxlY3Rpb24uZW5kID8/IDApIC0gKHNlbGVjdGlvbi5zdGFydCA/PyAwKSk7XG4gICAgaWYgKHNwYW4gPCA0KSB7XG4gICAgICAvLyBjb25zaWRlciB0b28gc21hbGwgdG8gem9vbVxuICAgICAgc2V0U2VsZWN0aW9uKHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCwgd2lkdGg6IGNoYXJ0V2lkdGggfSk7XG4gICAgICBzZXRJc1NlbGVjdGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVdpZHRoID0gTWF0aC5tYXgoc2VsZWN0aW9uLndpZHRoLCAxKTtcbiAgICBjb25zdCBzdGFydFJhdGlvID0gTWF0aC5taW4oc2VsZWN0aW9uLnN0YXJ0ISwgc2VsZWN0aW9uLmVuZCEpIC8gYmFzZVdpZHRoO1xuICAgIGNvbnN0IGVuZFJhdGlvID0gTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0ISwgc2VsZWN0aW9uLmVuZCEpIC8gYmFzZVdpZHRoO1xuICAgIGNvbnN0IGN1cnJlbnRTcGFuID0gTWF0aC5tYXgodmlld1JhbmdlWzFdIC0gdmlld1JhbmdlWzBdLCBOdW1iZXIuRVBTSUxPTik7XG4gICAgY29uc3QgbmV3U3RhcnQgPSBjbGFtcCh2aWV3UmFuZ2VbMF0gKyBzdGFydFJhdGlvICogY3VycmVudFNwYW4sIDAsIDEpO1xuICAgIGNvbnN0IG5ld0VuZCA9IGNsYW1wKHZpZXdSYW5nZVswXSArIGVuZFJhdGlvICogY3VycmVudFNwYW4sIDAsIDEpO1xuICAgIHNldFZpZXdSYW5nZShbbmV3U3RhcnQsIG5ld0VuZF0pO1xuICAgIHNldFNlbGVjdGlvbih7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwsIHdpZHRoOiBiYXNlV2lkdGggfSk7XG4gICAgc2V0SXNTZWxlY3RpbmcoZmFsc2UpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZU1vdXNlVXAgPSAoKSA9PiB7XG4gICAgZmluaXNoU2VsZWN0aW9uKCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcbiAgICBpZiAoaXNTZWxlY3RpbmcpIHtcbiAgICAgIGZpbmlzaFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBzZXRIb3ZlckluZm8obnVsbCk7XG4gIH07XG5cbiAgY29uc3QgYXBwbHlab29tID0gKHpvb21GYWN0b3I6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRTcGFuID0gTWF0aC5tYXgodmlld1JhbmdlWzFdIC0gdmlld1JhbmdlWzBdLCBtaW5WaWV3U3Bhbik7XG4gICAgY29uc3QgbmV3U3BhbiA9IGNsYW1wKGN1cnJlbnRTcGFuICogem9vbUZhY3RvciwgbWluVmlld1NwYW4sIDEpO1xuICAgIGNvbnN0IGNlbnRlciA9ICh2aWV3UmFuZ2VbMF0gKyB2aWV3UmFuZ2VbMV0pIC8gMjtcbiAgICBsZXQgbmV3U3RhcnQgPSBjZW50ZXIgLSBuZXdTcGFuIC8gMjtcbiAgICBsZXQgbmV3RW5kID0gY2VudGVyICsgbmV3U3BhbiAvIDI7XG4gICAgaWYgKG5ld1N0YXJ0IDwgMCkge1xuICAgICAgbmV3RW5kID0gTWF0aC5taW4oMSwgbmV3RW5kIC0gbmV3U3RhcnQpO1xuICAgICAgbmV3U3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAobmV3RW5kID4gMSkge1xuICAgICAgbmV3U3RhcnQgPSBNYXRoLm1heCgwLCBuZXdTdGFydCAtIChuZXdFbmQgLSAxKSk7XG4gICAgICBuZXdFbmQgPSAxO1xuICAgIH1cbiAgICBzZXRWaWV3UmFuZ2UoW25ld1N0YXJ0LCBuZXdFbmRdKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVab29tSW4gPSAoKSA9PiB7XG4gICAgYXBwbHlab29tKDAuNik7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlWm9vbU91dCA9ICgpID0+IHtcbiAgICBhcHBseVpvb20oMS41KTtcbiAgfTtcblxuICBjb25zdCByZXNldFpvb20gPSAoKSA9PiB7XG4gICAgc2V0Vmlld1JhbmdlKFswLCAxXSk7XG4gICAgc2V0U2VsZWN0aW9uKHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCwgd2lkdGg6IGNoYXJ0V2lkdGggfSk7XG4gIH07XG5cbiAgY29uc3QgdmlzaWJsZVNlcmllcyA9IHNlcmllcy5tYXAocyA9PiB7XG4gICAgY29uc3QgbWF4SW5kZXggPSBNYXRoLm1heChzLnZhbHVlcy5sZW5ndGggLSAxLCAwKTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIG1heEluZGV4KTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihlbmRJbmRleCwgbWF4SW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zLFxuICAgICAgdmlzaWJsZVZhbHVlczogcy52YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZCArIDEpXG4gICAgfTtcbiAgfSk7XG5cbiAgY29uc3QgY29tYmluZWRTZXJpZXNSYW5nZSA9ICgoKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzOiBudW1iZXJbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgcyBvZiB2aXNpYmxlU2VyaWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHMudmlzaWJsZVZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtaW46IE1hdGgubWluKC4uLnZhbHVlcyksXG4gICAgICBtYXg6IE1hdGgubWF4KC4uLnZhbHVlcylcbiAgICB9O1xuICB9KSgpO1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWRDb21iaW5lZFJhbmdlID0gKCgpID0+IHtcbiAgICBpZiAoIWNvbWJpbmVkU2VyaWVzUmFuZ2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tYmluZWRTZXJpZXNSYW5nZS5taW4gPT09IGNvbWJpbmVkU2VyaWVzUmFuZ2UubWF4KSB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gTWF0aC5tYXgoTWF0aC5hYnMoY29tYmluZWRTZXJpZXNSYW5nZS5taW4pICogMC4wNSwgMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IGNvbWJpbmVkU2VyaWVzUmFuZ2UubWluIC0gcGFkZGluZyxcbiAgICAgICAgbWF4OiBjb21iaW5lZFNlcmllc1JhbmdlLm1heCArIHBhZGRpbmdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5lZFNlcmllc1JhbmdlO1xuICB9KSgpO1xuXG4gIGNvbnN0IHZpc2libGVDb3JyZWxhdGlvbiA9ICgoKSA9PiB7XG4gICAgaWYgKCFjb3JyZWxhdGlvbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihzdGFydEluZGV4LCBjb3JyZWxhdGlvbi5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihlbmRJbmRleCwgY29ycmVsYXRpb24ubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIGNvcnJlbGF0aW9uLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgfSkoKTtcbiAgY29uc3QgdmlzaWJsZUNvaW50ZWdyYXRpb24gPSAoKCkgPT4ge1xuICAgIGlmICghY29pbnRlZ3JhdGlvbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihzdGFydEluZGV4LCBjb2ludGVncmF0aW9uLmxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGVuZEluZGV4LCBjb2ludGVncmF0aW9uLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBjb2ludGVncmF0aW9uLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgfSkoKTtcbiAgY29uc3QgbWV0cmljU2VyaWVzID0gbWV0cmljTW9kZSA9PT0gJ2NvcnJlbGF0aW9uJyA/IHZpc2libGVDb3JyZWxhdGlvbiA6IHZpc2libGVDb2ludGVncmF0aW9uO1xuXG4gIGNvbnN0IG1ldHJpY1JhbmdlID1cbiAgICBtZXRyaWNNb2RlID09PSAnY29ycmVsYXRpb24nXG4gICAgICA/IHsgbWluOiAtMSwgbWF4OiAxIH1cbiAgICAgIDogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCByYW5nZSA9IGdldFNlcmllc1JhbmdlKG1ldHJpY1Nlcmllcyk7XG4gICAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWluOiAtNSwgbWF4OiA1IH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1heEFicyA9IE1hdGgubWF4KE1hdGguYWJzKHJhbmdlLm1pbiksIE1hdGguYWJzKHJhbmdlLm1heCkpO1xuICAgICAgICAgIGNvbnN0IHBhZGRlZCA9IE1hdGgubWF4KG1heEFicyAqIDEuMSwgMSk7XG4gICAgICAgICAgcmV0dXJuIHsgbWluOiAtcGFkZGVkLCBtYXg6IHBhZGRlZCB9O1xuICAgICAgICB9KSgpO1xuXG4gIGNvbnN0IG1ldHJpY1BhdGggPSBidWlsZE1ldHJpY1BhdGgobWV0cmljU2VyaWVzLCBjaGFydFdpZHRoLCBjb3JyUGxvdEhlaWdodCwgbWV0cmljUmFuZ2UubWluLCBtZXRyaWNSYW5nZS5tYXgpO1xuXG4gIGNvbnN0IHZpc2libGVUaW1lc3RhbXBzID0gKCgpID0+IHtcbiAgICBpZiAoIXRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG1heEluZGV4ID0gTWF0aC5tYXgodGltZXN0YW1wcy5sZW5ndGggLSAxLCAwKTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIG1heEluZGV4KTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihlbmRJbmRleCwgbWF4SW5kZXgpO1xuICAgIHJldHVybiB0aW1lc3RhbXBzLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgfSkoKTtcblxuICBjb25zdCB0aW1lQXhpc1RpY2tzID0gYnVpbGRBeGlzVGlja3ModmlzaWJsZVRpbWVzdGFtcHMsIGNoYXJ0V2lkdGgpO1xuXG4gIGNvbnN0IGZpcnN0U2VyaWVzUmFuZ2UgPSBnZXRTZXJpZXNSYW5nZSh2aXNpYmxlU2VyaWVzWzBdPy52aXNpYmxlVmFsdWVzID8/IFtdKTtcbiAgY29uc3Qgc2Vjb25kU2VyaWVzUmFuZ2UgPSBnZXRTZXJpZXNSYW5nZSh2aXNpYmxlU2VyaWVzWzFdPy52aXNpYmxlVmFsdWVzID8/IFtdKTtcbiAgY29uc3QgZmlyc3RTZXJpZXNUaWNrcyA9IGZpcnN0U2VyaWVzUmFuZ2VcbiAgICA/IGJ1aWxkVmFsdWVUaWNrcyhmaXJzdFNlcmllc1JhbmdlLm1pbiwgZmlyc3RTZXJpZXNSYW5nZS5tYXgsIHNlcmllc1Bsb3RIZWlnaHQpXG4gICAgOiBbXTtcbiAgY29uc3Qgc2Vjb25kU2VyaWVzVGlja3MgPSBzZWNvbmRTZXJpZXNSYW5nZVxuICAgID8gYnVpbGRWYWx1ZVRpY2tzKHNlY29uZFNlcmllc1JhbmdlLm1pbiwgc2Vjb25kU2VyaWVzUmFuZ2UubWF4LCBzZXJpZXNQbG90SGVpZ2h0KVxuICAgIDogW107XG4gIGNvbnN0IGZpcnN0U2VyaWVzQ29sb3IgPSBnZXRTZXJpZXNDb2xvcigwKTtcbiAgY29uc3Qgc2Vjb25kU2VyaWVzQ29sb3IgPSBnZXRTZXJpZXNDb2xvcigxKTtcbiAgY29uc3Qgc2hhcmVkQXhpc1RpY2tzID1cbiAgICB0b3BTZXJpZXNNb2RlID09PSAnbm9ybWFsJyAmJiBub3JtYWxpemVkQ29tYmluZWRSYW5nZVxuICAgICAgPyBidWlsZFZhbHVlVGlja3Mobm9ybWFsaXplZENvbWJpbmVkUmFuZ2UubWluLCBub3JtYWxpemVkQ29tYmluZWRSYW5nZS5tYXgsIHNlcmllc1Bsb3RIZWlnaHQpXG4gICAgICA6IFtdO1xuXG4gIGNvbnN0IG1ldHJpY0F4aXNUaWNrcyA9IGJ1aWxkVmFsdWVUaWNrcyhtZXRyaWNSYW5nZS5taW4sIG1ldHJpY1JhbmdlLm1heCwgY29yclBsb3RIZWlnaHQpO1xuICBjb25zdCB6ZXJvTGluZVkgPVxuICAgIG1ldHJpY1JhbmdlLm1heCA9PT0gbWV0cmljUmFuZ2UubWluXG4gICAgICA/IGNvcnJQbG90SGVpZ2h0IC8gMlxuICAgICAgOiAoMSAtICgwIC0gbWV0cmljUmFuZ2UubWluKSAvIChtZXRyaWNSYW5nZS5tYXggLSBtZXRyaWNSYW5nZS5taW4pKSAqIGNvcnJQbG90SGVpZ2h0O1xuXG4gIGNvbnN0IHNlbGVjdGlvblggPSBzZWxlY3Rpb25BY3RpdmUgPyBNYXRoLm1pbihzZWxlY3Rpb24uc3RhcnQhLCBzZWxlY3Rpb24uZW5kISkgOiAwO1xuICBjb25zdCBzZWxlY3Rpb25XaWR0aCA9IHNlbGVjdGlvbkFjdGl2ZSA/IE1hdGguYWJzKChzZWxlY3Rpb24uZW5kID8/IDApIC0gKHNlbGVjdGlvbi5zdGFydCA/PyAwKSkgOiAwO1xuICBjb25zdCBsZWZ0QXhpc1ggPSAwO1xuICBjb25zdCByaWdodEF4aXNYID0gTWF0aC5tYXgoY2hhcnRXaWR0aCAtIDEsIDApO1xuXG4gIGNvbnN0IGNhblpvb21PdXQgPSAhKHZpZXdSYW5nZVswXSA9PT0gMCAmJiB2aWV3UmFuZ2VbMV0gPT09IDEpO1xuICBjb25zdCBjYW5ab29tSW4gPSB2aWV3UmFuZ2VbMV0gLSB2aWV3UmFuZ2VbMF0gPiBtaW5WaWV3U3BhbiAqIDEuMjtcbiAgY29uc3Qgem9vbUJ1dHRvblN0eWxlID0ge1xuICAgIHBhZGRpbmc6ICc0cHggOHB4JyxcbiAgICBiYWNrZ3JvdW5kOiAnIzMzMycsXG4gICAgY29sb3I6ICcjZmZmJyxcbiAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgYm9yZGVyUmFkaXVzOiA0LFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgd2lkdGg6IDMyLFxuICAgIGhlaWdodDogMzJcbiAgfTtcbiAgY29uc3QgZmxvYXRpbmdUb2dnbGVCdXR0b25TdHlsZTogUmVhY3QuQ1NTUHJvcGVydGllcyA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBsZWZ0OiA4LFxuICAgIHRvcDogOCxcbiAgICBwYWRkaW5nOiAnNHB4IDEwcHgnLFxuICAgIGJhY2tncm91bmQ6ICdyZ2JhKDUxLCA1MSwgNTEsIDAuOSknLFxuICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgIGJvcmRlclJhZGl1czogNCxcbiAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICB6SW5kZXg6IDEwLFxuICAgIGZvbnRTaXplOiAxMVxuICB9O1xuXG4gIGNvbnN0IG1ldHJpY01vZGVMYWJlbCA9XG4gICAgbWV0cmljTW9kZSA9PT0gJ2NvcnJlbGF0aW9uJyA/ICdSb2xsaW5nIGNvcnJlbGF0aW9uJyA6ICdDb2ludGVncmF0aW9uIHotc2NvcmUnO1xuICBjb25zdCB0b29sdGlwUG9zaXRpb24gPSAoKCkgPT4ge1xuICAgIGlmICghaG92ZXJJbmZvKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0ID0gMTI7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIDQsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIDQsIDApO1xuICAgIGNvbnN0IHRvb2x0aXBXaWR0aCA9IHRvb2x0aXBTaXplLndpZHRoIHx8IDA7XG4gICAgY29uc3QgdG9vbHRpcEhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodCB8fCAwO1xuICAgIGxldCBsZWZ0ID0gaG92ZXJJbmZvLnBvaW50ZXIueCArIG9mZnNldDtcbiAgICBsZXQgdG9wID0gaG92ZXJJbmZvLnBvaW50ZXIueSArIG9mZnNldDtcblxuICAgIGlmIChsZWZ0ICsgdG9vbHRpcFdpZHRoID4gYXZhaWxhYmxlV2lkdGgpIHtcbiAgICAgIGxlZnQgPSBob3ZlckluZm8ucG9pbnRlci54IC0gb2Zmc2V0IC0gdG9vbHRpcFdpZHRoO1xuICAgIH1cbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIGxlZnQgPSAwO1xuICAgIH1cblxuICAgIGlmICh0b3AgKyB0b29sdGlwSGVpZ2h0ID4gYXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICB0b3AgPSBob3ZlckluZm8ucG9pbnRlci55IC0gb2Zmc2V0IC0gdG9vbHRpcEhlaWdodDtcbiAgICB9XG4gICAgaWYgKHRvcCA8IDApIHtcbiAgICAgIHRvcCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbGVmdCwgdG9wIH07XG4gIH0pKCk7XG4gIGNvbnN0IGFjdGl2ZU1ldHJpY1ZhbHVlID1cbiAgICBob3ZlckluZm8gPT09IG51bGxcbiAgICAgID8gbnVsbFxuICAgICAgOiBtZXRyaWNNb2RlID09PSAnY29ycmVsYXRpb24nXG4gICAgICAgICAgPyBob3ZlckluZm8ubWV0cmljcy5jb3JyZWxhdGlvblxuICAgICAgICAgIDogaG92ZXJJbmZvLm1ldHJpY3MuY29pbnRlZ3JhdGlvbjtcblxuICBjb25zdCBkYXRlTGFiZWxIZWlnaHQgPSAxNjtcbiAgY29uc3QgZGF0ZUxhYmVsWSA9IE1hdGgubWF4KGNvcnJQbG90SGVpZ2h0ICsgMTIsIGJvdHRvbUhlaWdodCAtIGRhdGVMYWJlbEhlaWdodCAtIDQpO1xuICBjb25zdCB0aW1lQXhpc0xhYmVsWSA9IE1hdGgubWF4KGNvcnJQbG90SGVpZ2h0ICsgNiwgTWF0aC5taW4oY29yclBsb3RIZWlnaHQgKyAxMCwgZGF0ZUxhYmVsWSAtIDQpKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHJlZj17Y29udGFpbmVyUmVmfVxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgcGFkZGluZzogMTAsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgZ2FwOiA4LFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgIH19XG4gICAgPlxuICAgICAge2hvdmVySW5mbyAmJiB0b29sdGlwUG9zaXRpb24gJiYgKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgcmVmPXtob3ZlclJlZn1cbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBsZWZ0OiB0b29sdGlwUG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIHRvcDogdG9vbHRpcFBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICdyZ2JhKDAsMCwwLDAuOSknLFxuICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTJweCcsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDQsXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICB6SW5kZXg6IDEwMDAsXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpJ1xuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2PlRpbWU6IHtob3ZlckluZm8udGltZUxhYmVsfTwvZGl2PlxuICAgICAgICAgIHtob3ZlckluZm8uc2VyaWVzVmFsdWVzLm1hcCgoeyBuYW1lLCB2YWx1ZSB9KSA9PiAoXG4gICAgICAgICAgICA8ZGl2IGtleT17bmFtZX0+XG4gICAgICAgICAgICAgIHtuYW1lfToge3ZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyAnTi9BJyA6IHZhbHVlLnRvTG9jYWxlU3RyaW5nKCl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApKX1cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAge21ldHJpY01vZGVMYWJlbH06IHthY3RpdmVNZXRyaWNWYWx1ZSA9PT0gbnVsbCA/ICdOL0EnIDogYWN0aXZlTWV0cmljVmFsdWUudG9GaXhlZCgzKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgPGRpdiByZWY9e2Nocm9tZVJlZn0gc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnLCBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJywgZ2FwOiA4IH19PlxuICAgICAgICB7LyogPGgzIHN0eWxlPXt7IGNvbG9yOiAnI2RkZCcsIG1hcmdpbjogMCB9fT5cbiAgICAgICAgICBcbiAgICAgICAgPC9oMz4gKi99XG4gICAgICAgIDxoM1xuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBjb2xvcjogJyNkZGQnLFxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIEVuZXMgQmVrZGVtaXIgLSAyMDI1NTAyMDAwIC0gUm9sbGluZyBQZWFyc29uIENvcnJlbGF0aW9uOiB7c2VyaWVzWzBdLm5hbWV9IHZzIHtzZXJpZXNbMV0ubmFtZX1cbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JywgZ2FwOiA4IH19PlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVab29tT3V0fVxuICAgICAgICAgICAgICBkaXNhYmxlZD17IWNhblpvb21PdXR9XG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgLi4uem9vbUJ1dHRvblN0eWxlLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogY2FuWm9vbU91dCA/ICdwb2ludGVyJyA6ICdub3QtYWxsb3dlZCcsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogY2FuWm9vbU91dCA/IDEgOiAwLjRcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlpvb20gb3V0XCJcbiAgICAgICAgICAgICAgdGl0bGU9XCJab29tIG91dFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgICAgICAgIDxjaXJjbGUgY3g9XCI2LjVcIiBjeT1cIjYuNVwiIHI9XCI0LjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBmaWxsPVwibm9uZVwiIHN0cm9rZVdpZHRoPVwiMS41XCIgLz5cbiAgICAgICAgICAgICAgICA8bGluZSB4MT1cIjRcIiB5MT1cIjYuNVwiIHgyPVwiOVwiIHkyPVwiNi41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlV2lkdGg9XCIxLjVcIiAvPlxuICAgICAgICAgICAgICAgIDxsaW5lIHgxPVwiOS41XCIgeTE9XCI5LjVcIiB4Mj1cIjEzLjVcIiB5Mj1cIjEzLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2VXaWR0aD1cIjEuNVwiIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIC8+XG4gICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVpvb21Jbn1cbiAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFjYW5ab29tSW59XG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgLi4uem9vbUJ1dHRvblN0eWxlLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogY2FuWm9vbUluID8gJ3BvaW50ZXInIDogJ25vdC1hbGxvd2VkJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBjYW5ab29tSW4gPyAxIDogMC40XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJab29tIGluXCJcbiAgICAgICAgICAgICAgdGl0bGU9XCJab29tIGluXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgPGNpcmNsZSBjeD1cIjYuNVwiIGN5PVwiNi41XCIgcj1cIjQuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGZpbGw9XCJub25lXCIgc3Ryb2tlV2lkdGg9XCIxLjVcIiAvPlxuICAgICAgICAgICAgICAgIDxsaW5lIHgxPVwiNFwiIHkxPVwiNi41XCIgeDI9XCI5XCIgeTI9XCI2LjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2VXaWR0aD1cIjEuNVwiIC8+XG4gICAgICAgICAgICAgICAgPGxpbmUgeDE9XCI2LjVcIiB5MT1cIjRcIiB4Mj1cIjYuNVwiIHkyPVwiOVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZVdpZHRoPVwiMS41XCIgLz5cbiAgICAgICAgICAgICAgICA8bGluZSB4MT1cIjkuNVwiIHkxPVwiOS41XCIgeDI9XCIxMy41XCIgeTI9XCIxMy41XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlV2lkdGg9XCIxLjVcIiBzdHJva2VMaW5lY2FwPVwicm91bmRcIiAvPlxuICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBvbkNsaWNrPXtyZXNldFpvb219XG4gICAgICAgICAgICAgIGRpc2FibGVkPXshY2FuWm9vbU91dH1cbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnNHB4IDhweCcsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJyMzMzMnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcbiAgICAgICAgICAgICAgICBjdXJzb3I6IGNhblpvb21PdXQgPyAncG9pbnRlcicgOiAnbm90LWFsbG93ZWQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFJlc2V0IHpvb21cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2gzPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGdhcDogMTYsXG4gICAgICAgICAgICBjb2xvcjogJyNkZGQnLFxuICAgICAgICAgICAgZmxleFdyYXA6ICd3cmFwJ1xuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JywgZ2FwOiAxNiwgZmxleFdyYXA6ICd3cmFwJywgYWxpZ25JdGVtczogJ2NlbnRlcicgfX0+XG4gICAgICAgICAgICB7c2VyaWVzLnNsaWNlKDAsIDIpLm1hcCgocywgaWR4KSA9PiAoXG4gICAgICAgICAgICAgIDxkaXYga2V5PXtgJHtzLm5hbWV9LSR7aWR4fWB9IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicsIGdhcDogNiB9fT5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEyLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDIsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGdldFNlcmllc0NvbG9yKGlkeCksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPHNwYW4+e3MubmFtZX08L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgc3R5bGU9e3sgZmxleDogMSwgbWluSGVpZ2h0OiAwLCBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLCBnYXA6IDggfX0+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgcG9zaXRpb246ICdyZWxhdGl2ZScsIGZsZXg6ICcwIDAgYXV0bycsIGhlaWdodDogdG9wSGVpZ2h0IH19PlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFRvcFNlcmllc01vZGUodG9wU2VyaWVzTW9kZSA9PT0gJ3JlbGF0aXZlJyA/ICdub3JtYWwnIDogJ3JlbGF0aXZlJyl9XG4gICAgICAgICAgICBzdHlsZT17ZmxvYXRpbmdUb2dnbGVCdXR0b25TdHlsZX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7dG9wU2VyaWVzTW9kZSA9PT0gJ3JlbGF0aXZlJyA/ICdSZWxhdGl2ZSB2YWx1ZXMnIDogJ1JlYWwgdmFsdWVzJ31cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICB7LyogLS0tIFRvcCBjaGFydDogdGhlIGFjdHVhbCBzZXJpZXMgLS0tICovfVxuICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgIHdpZHRoPXtjaGFydFdpZHRofVxuICAgICAgICAgICAgaGVpZ2h0PXt0b3BIZWlnaHR9XG4gICAgICAgICAgICBzdHlsZT17eyBiYWNrZ3JvdW5kOiAnIzExMScsIGN1cnNvcjogJ2Nyb3NzaGFpcicsIGRpc3BsYXk6ICdibG9jaycgfX1cbiAgICAgICAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVNb3VzZURvd259XG4gICAgICAgICAgICBvbk1vdXNlTW92ZT17aGFuZGxlTW91c2VNb3ZlfVxuICAgICAgICAgICAgb25Nb3VzZVVwPXtoYW5kbGVNb3VzZVVwfVxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVNb3VzZUxlYXZlfVxuICAgICAgICAgID5cbiAgICAgICAgICB7dmlzaWJsZVNlcmllcy5tYXAoKHMsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZVZhbHVlcyA9IHMudmlzaWJsZVZhbHVlcy5sZW5ndGggPyBzLnZpc2libGVWYWx1ZXMgOiBbXTtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFJhbmdlID1cbiAgICAgICAgICAgICAgdG9wU2VyaWVzTW9kZSA9PT0gJ25vcm1hbCcgJiYgbm9ybWFsaXplZENvbWJpbmVkUmFuZ2VcbiAgICAgICAgICAgICAgICA/IG5vcm1hbGl6ZWRDb21iaW5lZFJhbmdlXG4gICAgICAgICAgICAgICAgOiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi52aXNpYmxlVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4udmlzaWJsZVZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSBNYXRoLm1heChNYXRoLmFicyhtaW4pICogMC4wNSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbWluOiBtaW4gLSBwYWRkaW5nLCBtYXg6IG1heCArIHBhZGRpbmcgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBtaW4sIG1heCB9O1xuICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHZpc2libGVWYWx1ZXNcbiAgICAgICAgICAgICAgLm1hcCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9tID0gTWF0aC5tYXgodmlzaWJsZVZhbHVlcy5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gKGkgLyBkZW5vbSkgKiBjaGFydFdpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBub3JtYWxpemUodiwgbG9jYWxSYW5nZS5taW4sIGxvY2FsUmFuZ2UubWF4LCBzZXJpZXNQbG90SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7eH0sJHt5fWA7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5qb2luKCcgTCAnKTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICBrZXk9e2lkeH1cbiAgICAgICAgICAgICAgICBkPXtgTSAke3BhdGh9YH1cbiAgICAgICAgICAgICAgICBzdHJva2U9e2dldFNlcmllc0NvbG9yKGlkeCl9XG4gICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXtpZHggPD0gMSA/IDIgOiAxfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KX1cbiAgICAgICAgICB7c2VsZWN0aW9uQWN0aXZlICYmIChcbiAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgIHg9e3NlbGVjdGlvblh9XG4gICAgICAgICAgICAgIHk9ezB9XG4gICAgICAgICAgICAgIHdpZHRoPXtzZWxlY3Rpb25XaWR0aH1cbiAgICAgICAgICAgICAgaGVpZ2h0PXtzZXJpZXNQbG90SGVpZ2h0fVxuICAgICAgICAgICAgICBmaWxsPVwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpXCJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwiI2ZmZlwiXG4gICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjRcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICAgIHt0b3BTZXJpZXNNb2RlID09PSAncmVsYXRpdmUnICYmIGZpcnN0U2VyaWVzVGlja3MubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICA8Zz5cbiAgICAgICAgICAgICAgPGxpbmUgeDE9e2xlZnRBeGlzWH0geTE9ezB9IHgyPXtsZWZ0QXhpc1h9IHkyPXtzZXJpZXNQbG90SGVpZ2h0fSBzdHJva2U9XCIjMzMzXCIgc3Ryb2tlV2lkdGg9ezF9IC8+XG4gICAgICAgICAgICAgIHtmaXJzdFNlcmllc1RpY2tzLm1hcCgodGljaywgaWR4KSA9PiAoXG4gICAgICAgICAgICAgICAgPGcga2V5PXtgbGVmdC12YWx1ZS1heGlzLSR7aWR4fWB9PlxuICAgICAgICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgICAgICAgeDE9e2xlZnRBeGlzWH1cbiAgICAgICAgICAgICAgICAgICAgeTE9e3RpY2sueX1cbiAgICAgICAgICAgICAgICAgICAgeDI9e2xlZnRBeGlzWCArIDZ9XG4gICAgICAgICAgICAgICAgICAgIHkyPXt0aWNrLnl9XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT17Zmlyc3RTZXJpZXNDb2xvcn1cbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPHRleHRcbiAgICAgICAgICAgICAgICAgICAgeD17bGVmdEF4aXNYICsgOH1cbiAgICAgICAgICAgICAgICAgICAgeT17dGljay55fVxuICAgICAgICAgICAgICAgICAgICBmaWxsPXtmaXJzdFNlcmllc0NvbG9yfVxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17MTB9XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJzdGFydFwiXG4gICAgICAgICAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7dGljay5sYWJlbH1cbiAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICl9XG4gICAgICAgICAge3RvcFNlcmllc01vZGUgPT09ICdyZWxhdGl2ZScgJiYgc2Vjb25kU2VyaWVzVGlja3MubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICA8Zz5cbiAgICAgICAgICAgICAgPGxpbmUgeDE9e3JpZ2h0QXhpc1h9IHkxPXswfSB4Mj17cmlnaHRBeGlzWH0geTI9e3Nlcmllc1Bsb3RIZWlnaHR9IHN0cm9rZT1cIiMzMzNcIiBzdHJva2VXaWR0aD17MX0gLz5cbiAgICAgICAgICAgICAge3NlY29uZFNlcmllc1RpY2tzLm1hcCgodGljaywgaWR4KSA9PiAoXG4gICAgICAgICAgICAgICAgPGcga2V5PXtgcmlnaHQtdmFsdWUtYXhpcy0ke2lkeH1gfT5cbiAgICAgICAgICAgICAgICAgIDxsaW5lXG4gICAgICAgICAgICAgICAgICAgIHgxPXtyaWdodEF4aXNYIC0gNn1cbiAgICAgICAgICAgICAgICAgICAgeTE9e3RpY2sueX1cbiAgICAgICAgICAgICAgICAgICAgeDI9e3JpZ2h0QXhpc1h9XG4gICAgICAgICAgICAgICAgICAgIHkyPXt0aWNrLnl9XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT17c2Vjb25kU2VyaWVzQ29sb3J9XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgICAgIHg9e3JpZ2h0QXhpc1ggLSA4fVxuICAgICAgICAgICAgICAgICAgICB5PXt0aWNrLnl9XG4gICAgICAgICAgICAgICAgICAgIGZpbGw9e3NlY29uZFNlcmllc0NvbG9yfVxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17MTB9XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJlbmRcIlxuICAgICAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwibWlkZGxlXCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge3RpY2subGFiZWx9XG4gICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICApfVxuICAgICAgICAgIHt0b3BTZXJpZXNNb2RlID09PSAnbm9ybWFsJyAmJiBzaGFyZWRBeGlzVGlja3MubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICA8Zz5cbiAgICAgICAgICAgICAgPGxpbmUgeDE9e3JpZ2h0QXhpc1h9IHkxPXswfSB4Mj17cmlnaHRBeGlzWH0geTI9e3Nlcmllc1Bsb3RIZWlnaHR9IHN0cm9rZT1cIiMzMzNcIiBzdHJva2VXaWR0aD17MX0gLz5cbiAgICAgICAgICAgICAge3NoYXJlZEF4aXNUaWNrcy5tYXAoKHRpY2ssIGlkeCkgPT4gKFxuICAgICAgICAgICAgICAgIDxnIGtleT17YHNoYXJlZC12YWx1ZS1heGlzLSR7aWR4fWB9PlxuICAgICAgICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgICAgICAgeDE9e3JpZ2h0QXhpc1ggLSA2fVxuICAgICAgICAgICAgICAgICAgICB5MT17dGljay55fVxuICAgICAgICAgICAgICAgICAgICB4Mj17cmlnaHRBeGlzWH1cbiAgICAgICAgICAgICAgICAgICAgeTI9e3RpY2sueX1cbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiI2JiYlwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsxfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgICAgIHg9e3JpZ2h0QXhpc1ggLSA4fVxuICAgICAgICAgICAgICAgICAgICB5PXt0aWNrLnl9XG4gICAgICAgICAgICAgICAgICAgIGZpbGw9XCIjYmJiXCJcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU9ezEwfVxuICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwiZW5kXCJcbiAgICAgICAgICAgICAgICAgICAgZG9taW5hbnRCYXNlbGluZT1cIm1pZGRsZVwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHt0aWNrLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9zdmc+XG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgey8qIC0tLSBCb3R0b20gY2hhcnQ6IG1ldHJpYyAtLS0gKi99XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBzdHlsZT17eyBwb3NpdGlvbjogJ3JlbGF0aXZlJywgZmxleDogJzAgMCBhdXRvJywgaGVpZ2h0OiBib3R0b21IZWlnaHQgfX1cbiAgICAgICAgICBvbk1vdXNlTGVhdmU9e2hhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgID5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNZXRyaWNNb2RlKG1ldHJpY01vZGUgPT09ICdjb3JyZWxhdGlvbicgPyAnY29pbnRlZ3JhdGlvbicgOiAnY29ycmVsYXRpb24nKX1cbiAgICAgICAgICAgIHN0eWxlPXtmbG9hdGluZ1RvZ2dsZUJ1dHRvblN0eWxlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHttZXRyaWNNb2RlTGFiZWx9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgd2lkdGg9e2NoYXJ0V2lkdGh9XG4gICAgICAgICAgICBoZWlnaHQ9e2JvdHRvbUhlaWdodH1cbiAgICAgICAgICAgIHN0eWxlPXt7IGJhY2tncm91bmQ6ICcjMjIyJywgY3Vyc29yOiAnY3Jvc3NoYWlyJywgZGlzcGxheTogJ2Jsb2NrJyB9fVxuICAgICAgICAgICAgb25Nb3VzZURvd249e2hhbmRsZU1vdXNlRG93bn1cbiAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtoYW5kbGVNb3VzZU1vdmV9XG4gICAgICAgICAgICBvbk1vdXNlVXA9e2hhbmRsZU1vdXNlVXB9XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI9e2hhbmRsZU1vdXNlTW92ZX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8ZGVmcz5cbiAgICAgICAgICAgICAgPGNsaXBQYXRoIGlkPVwibWV0cmljQ2xpcFBhdGhcIj5cbiAgICAgICAgICAgICAgICA8cmVjdCB4PXswfSB5PXswfSB3aWR0aD17Y2hhcnRXaWR0aH0gaGVpZ2h0PXtjb3JyUGxvdEhlaWdodH0gLz5cbiAgICAgICAgICAgICAgPC9jbGlwUGF0aD5cbiAgICAgICAgICAgIDwvZGVmcz5cbiAgICAgICAgICAgIDxyZWN0IHg9ezB9IHk9ezB9IHdpZHRoPXtjaGFydFdpZHRofSBoZWlnaHQ9e2NvcnJQbG90SGVpZ2h0fSBmaWxsPVwiIzIyMlwiIC8+XG4gICAgICAgICAgICA8bGluZSB4MT17MH0geTE9e3plcm9MaW5lWX0geDI9e2NoYXJ0V2lkdGh9IHkyPXt6ZXJvTGluZVl9IHN0cm9rZT1cIiM2NjZcIiBzdHJva2VEYXNoYXJyYXk9XCI0XCIgc3Ryb2tlV2lkdGg9ezF9IC8+XG4gICAgICAgICAgICB7bWV0cmljUGF0aCAmJiAoXG4gICAgICAgICAgICAgIDxnIGNsaXBQYXRoPVwidXJsKCNtZXRyaWNDbGlwUGF0aClcIj5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPXttZXRyaWNQYXRofSBzdHJva2U9XCIjNjBjZmZmXCIgc3Ryb2tlV2lkdGg9ezJ9IGZpbGw9XCJub25lXCIgLz5cbiAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHtzZWxlY3Rpb25BY3RpdmUgJiYgKFxuICAgICAgICAgICAgICA8cmVjdFxuICAgICAgICAgICAgICAgIHg9e3NlbGVjdGlvblh9XG4gICAgICAgICAgICAgICAgeT17MH1cbiAgICAgICAgICAgICAgICB3aWR0aD17c2VsZWN0aW9uV2lkdGh9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXtjb3JyUGxvdEhlaWdodH1cbiAgICAgICAgICAgICAgICBmaWxsPVwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA4KVwiXG4gICAgICAgICAgICAgICAgc3Ryb2tlPVwiI2ZmZlwiXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5PVwiNFwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgPGxpbmUgeDE9e3JpZ2h0QXhpc1h9IHkxPXswfSB4Mj17cmlnaHRBeGlzWH0geTI9e2NvcnJQbG90SGVpZ2h0fSBzdHJva2U9XCIjMzMzXCIgc3Ryb2tlV2lkdGg9ezF9IC8+XG4gICAgICAgICAgICB7bWV0cmljQXhpc1RpY2tzLm1hcCgodGljaywgaWR4KSA9PiAoXG4gICAgICAgICAgICAgIDxnIGtleT17YGNvcnItdmFsdWUtYXhpcy0ke2lkeH1gfT5cbiAgICAgICAgICAgICAgICA8bGluZVxuICAgICAgICAgICAgICAgICAgeDE9e3JpZ2h0QXhpc1ggLSA2fVxuICAgICAgICAgICAgICAgICAgeTE9e3RpY2sueX1cbiAgICAgICAgICAgICAgICAgIHgyPXtyaWdodEF4aXNYfVxuICAgICAgICAgICAgICAgICAgeTI9e3RpY2sueX1cbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cIiM1NTVcIlxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICAgICAgeD17cmlnaHRBeGlzWCAtIDh9XG4gICAgICAgICAgICAgICAgICB5PXt0aWNrLnl9XG4gICAgICAgICAgICAgICAgICBmaWxsPVwiI2JiYlwiXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZT17MTB9XG4gICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwiZW5kXCJcbiAgICAgICAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHt0aWNrLmxhYmVsfVxuICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8bGluZSB4MT17MH0geTE9e2NvcnJQbG90SGVpZ2h0fSB4Mj17Y2hhcnRXaWR0aH0geTI9e2NvcnJQbG90SGVpZ2h0fSBzdHJva2U9XCIjMzMzXCIgc3Ryb2tlV2lkdGg9ezF9IC8+XG4gICAgICAgICAgICB7dGltZUF4aXNUaWNrcy5tYXAoKHRpY2ssIGlkeCkgPT4gKFxuICAgICAgICAgICAgICA8ZyBrZXk9e2Bjb3JyLWF4aXMtJHtpZHh9YH0+XG4gICAgICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgICAgIHgxPXt0aWNrLnh9XG4gICAgICAgICAgICAgICAgICB5MT17Y29yclBsb3RIZWlnaHR9XG4gICAgICAgICAgICAgICAgICB4Mj17dGljay54fVxuICAgICAgICAgICAgICAgICAgeTI9e2NvcnJQbG90SGVpZ2h0ICsgNn1cbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cIiM1NTVcIlxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICAgICAgeD17dGljay54fVxuICAgICAgICAgICAgICAgICAgeT17dGltZUF4aXNMYWJlbFl9XG4gICAgICAgICAgICAgICAgICBmaWxsPVwiI2JiYlwiXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZT17MTB9XG4gICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJoYW5naW5nXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7dGljay5sYWJlbH1cbiAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiY29tcHV0ZUNvaW50ZWdyYXRpb25aU2NvcmUiLCJzbGlkaW5nQ29ycmVsYXRpb24iLCJzbW9vdGhTZXJpZXMiLCJTRVJJRVNfQ09MT1JTIiwiZ2V0U2VyaWVzQ29sb3IiLCJpbmRleCIsImZvcm1hdFRpbWVzdGFtcCIsInZhbHVlIiwidW5kZWZpbmVkIiwiZGF0ZSIsIkRhdGUiLCJ2YWx1ZU9mIiwiTnVtYmVyIiwiaXNOYU4iLCJnZXRUaW1lIiwiU3RyaW5nIiwidG9Mb2NhbGVTdHJpbmciLCJnZXRUaW1lVmFsdWUiLCJkIiwidGltZSIsInZhbCIsImlzRmluaXRlIiwibnVtZXJpYyIsImJ1aWxkQXhpc1RpY2tzIiwidmFsdWVzIiwidG90YWxXaWR0aCIsImxlbmd0aCIsInNhZmVXaWR0aCIsIk1hdGgiLCJtYXgiLCJjb3VudCIsIm1pbiIsIngiLCJsYWJlbCIsImxhc3RJbmRleCIsIkFycmF5IiwiZnJvbSIsIl8iLCJpZHgiLCJyYXRpbyIsInRhcmdldEluZGV4Iiwicm91bmQiLCJidWlsZFZhbHVlVGlja3MiLCJoZWlnaHQiLCJ5Iiwic3RlcHMiLCJyYW5nZSIsImdldFNlcmllc1JhbmdlIiwibnVtZXJpY1ZhbHVlcyIsImZpbHRlciIsImJ1aWxkTWV0cmljUGF0aCIsImNoYXJ0V2lkdGgiLCJwbG90SGVpZ2h0IiwiZGVub20iLCJwYXRoIiwiaGFzT3BlblNlZ21lbnQiLCJmb3JFYWNoIiwiY2xhbXBlZCIsIm5vcm1hbGl6ZWQiLCJDb3JyZWxhdGlvblBhbmVsIiwiZGF0YSIsIndpZHRoIiwib3B0aW9ucyIsInZpc2libGVTZXJpZXMiLCJob3Jpem9udGFsUGFkZGluZyIsInZlcnRpY2FsUGFkZGluZyIsInZpZXdSYW5nZSIsInNldFZpZXdSYW5nZSIsInNlbGVjdGlvbiIsInNldFNlbGVjdGlvbiIsInN0YXJ0IiwiZW5kIiwiaXNTZWxlY3RpbmciLCJzZXRJc1NlbGVjdGluZyIsImhvdmVySW5mbyIsInNldEhvdmVySW5mbyIsIm1ldHJpY01vZGUiLCJzZXRNZXRyaWNNb2RlIiwidG9wU2VyaWVzTW9kZSIsInNldFRvcFNlcmllc01vZGUiLCJ0b29sdGlwU2l6ZSIsInNldFRvb2x0aXBTaXplIiwiY2hyb21lSGVpZ2h0Iiwic2V0Q2hyb21lSGVpZ2h0IiwiY29udGFpbmVyUmVmIiwiY2hyb21lUmVmIiwiaG92ZXJSZWYiLCJjdXJyZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInByZXYiLCJtZWFzdXJlIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlciIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwidGltZUZpZWxkIiwibnVtZXJpY0ZpZWxkcyIsImZyYW1lIiwic2VyaWVzIiwidCIsImZpZWxkcyIsImZpbmQiLCJmIiwidHlwZSIsIm51bXMiLCJwdXNoIiwiZGl2IiwidGltZXN0YW1wcyIsInRvQXJyYXkiLCJmaXJzdFRpbWUiLCJsYXN0VGltZSIsImlzVGltZURlc2NlbmRpbmciLCJyZXZlcnNlIiwibWFwIiwibmFtZSIsInNsaWNlIiwid2luZG93Iiwid2luZG93U2l6ZSIsInJhd0NvcnJlbGF0aW9uIiwic21vb3RoaW5nUmFkaXVzIiwiZmxvb3IiLCJjb3JyZWxhdGlvbiIsInJhd0NvaW50ZWdyYXRpb24iLCJjb2ludGVncmF0aW9uIiwidG90YWxQb2ludHMiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJjZWlsIiwic2VsZWN0aW9uQWN0aXZlIiwibm9ybWFsaXplIiwidiIsImgiLCJhdmFpbGFibGVQbG90SGVpZ2h0IiwidG9wSGVpZ2h0IiwiYm90dG9tSGVpZ2h0Iiwic2VyaWVzUGxvdEhlaWdodCIsIm1heEF4aXNQYWRkaW5nIiwiYm90dG9tQXhpc1BhZGRpbmciLCJjb3JyUGxvdEhlaWdodCIsImNsYW1wIiwibWluVmlld1NwYW4iLCJ1cGRhdGVIb3ZlclN0YXRlIiwibG9jYWxYIiwibG9jYWxXaWR0aCIsInBvaW50ZXIiLCJyYXRpb1dpdGhpblZpZXciLCJzcGFuSW5kaWNlcyIsImRhdGFJbmRleCIsInRpbWVWYWx1ZSIsInNlcmllc1ZhbHVlc0F0UG9pbnRlciIsInMiLCJjb3JyZWxhdGlvblZhbHVlIiwiY29pbnRlZ3JhdGlvblZhbHVlIiwidGltZUxhYmVsIiwic2VyaWVzVmFsdWVzIiwibWV0cmljcyIsImV4dHJhY3RQb2ludGVyRGF0YSIsImV2ZW50IiwiYm91bmRzIiwiY3VycmVudFRhcmdldCIsImNsaWVudFgiLCJsZWZ0IiwiY29udGFpbmVyQm91bmRzIiwicmVmZXJlbmNlQm91bmRzIiwicmVmV2lkdGgiLCJyZWZIZWlnaHQiLCJjbGllbnRZIiwidG9wIiwiaGFuZGxlTW91c2VEb3duIiwiaGFuZGxlTW91c2VNb3ZlIiwic2VsIiwiZmluaXNoU2VsZWN0aW9uIiwic3BhbiIsImFicyIsImJhc2VXaWR0aCIsInN0YXJ0UmF0aW8iLCJlbmRSYXRpbyIsImN1cnJlbnRTcGFuIiwiRVBTSUxPTiIsIm5ld1N0YXJ0IiwibmV3RW5kIiwiaGFuZGxlTW91c2VVcCIsImhhbmRsZU1vdXNlTGVhdmUiLCJhcHBseVpvb20iLCJ6b29tRmFjdG9yIiwibmV3U3BhbiIsImNlbnRlciIsImhhbmRsZVpvb21JbiIsImhhbmRsZVpvb21PdXQiLCJyZXNldFpvb20iLCJtYXhJbmRleCIsInZpc2libGVWYWx1ZXMiLCJjb21iaW5lZFNlcmllc1JhbmdlIiwibm9ybWFsaXplZENvbWJpbmVkUmFuZ2UiLCJwYWRkaW5nIiwidmlzaWJsZUNvcnJlbGF0aW9uIiwidmlzaWJsZUNvaW50ZWdyYXRpb24iLCJtZXRyaWNTZXJpZXMiLCJtZXRyaWNSYW5nZSIsIm1heEFicyIsInBhZGRlZCIsIm1ldHJpY1BhdGgiLCJ2aXNpYmxlVGltZXN0YW1wcyIsInRpbWVBeGlzVGlja3MiLCJmaXJzdFNlcmllc1JhbmdlIiwic2Vjb25kU2VyaWVzUmFuZ2UiLCJmaXJzdFNlcmllc1RpY2tzIiwic2Vjb25kU2VyaWVzVGlja3MiLCJmaXJzdFNlcmllc0NvbG9yIiwic2Vjb25kU2VyaWVzQ29sb3IiLCJzaGFyZWRBeGlzVGlja3MiLCJtZXRyaWNBeGlzVGlja3MiLCJ6ZXJvTGluZVkiLCJzZWxlY3Rpb25YIiwic2VsZWN0aW9uV2lkdGgiLCJsZWZ0QXhpc1giLCJyaWdodEF4aXNYIiwiY2FuWm9vbU91dCIsImNhblpvb21JbiIsInpvb21CdXR0b25TdHlsZSIsImJhY2tncm91bmQiLCJjb2xvciIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsImRpc3BsYXkiLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJmbG9hdGluZ1RvZ2dsZUJ1dHRvblN0eWxlIiwicG9zaXRpb24iLCJjdXJzb3IiLCJ6SW5kZXgiLCJmb250U2l6ZSIsIm1ldHJpY01vZGVMYWJlbCIsInRvb2x0aXBQb3NpdGlvbiIsIm9mZnNldCIsImF2YWlsYWJsZVdpZHRoIiwiYXZhaWxhYmxlSGVpZ2h0IiwidG9vbHRpcFdpZHRoIiwidG9vbHRpcEhlaWdodCIsImFjdGl2ZU1ldHJpY1ZhbHVlIiwiZGF0ZUxhYmVsSGVpZ2h0IiwiZGF0ZUxhYmVsWSIsInRpbWVBeGlzTGFiZWxZIiwicmVmIiwic3R5bGUiLCJib3hTaXppbmciLCJmbGV4RGlyZWN0aW9uIiwiZ2FwIiwib3ZlcmZsb3ciLCJwb2ludGVyRXZlbnRzIiwia2V5IiwidG9GaXhlZCIsImgzIiwibWFyZ2luIiwiYnV0dG9uIiwib25DbGljayIsImRpc2FibGVkIiwib3BhY2l0eSIsImFyaWEtbGFiZWwiLCJ0aXRsZSIsInN2ZyIsInZpZXdCb3giLCJhcmlhLWhpZGRlbiIsImNpcmNsZSIsImN4IiwiY3kiLCJyIiwic3Ryb2tlIiwiZmlsbCIsInN0cm9rZVdpZHRoIiwibGluZSIsIngxIiwieTEiLCJ4MiIsInkyIiwic3Ryb2tlTGluZWNhcCIsImZsZXhXcmFwIiwiZmxleCIsIm1pbkhlaWdodCIsIm9uTW91c2VEb3duIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJsb2NhbFJhbmdlIiwiaSIsImpvaW4iLCJzdHJva2VEYXNoYXJyYXkiLCJnIiwidGljayIsInRleHQiLCJ0ZXh0QW5jaG9yIiwiZG9taW5hbnRCYXNlbGluZSIsIm9uTW91c2VFbnRlciIsImRlZnMiLCJjbGlwUGF0aCIsImlkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./CorrelationPanel.tsx\n\n}");

/***/ }),

/***/ "./module.ts":
/*!*******************!*\
  !*** ./module.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   plugin: () => (/* binding */ plugin)\n/* harmony export */ });\n/* harmony import */ var grafana_public_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! grafana-public-path */ \"./node_modules/grafana-public-path.js\");\n/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @grafana/data */ \"@grafana/data\");\n/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_grafana_data__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _CorrelationPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CorrelationPanel */ \"./CorrelationPanel.tsx\");\n/*** IMPORTS FROM imports-loader ***/\n\n\n\n\nconst plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.PanelPlugin(_CorrelationPanel__WEBPACK_IMPORTED_MODULE_2__.CorrelationPanel).setPanelOptions((builder)=>{\n    builder.addNumberInput({\n        path: 'windowSize',\n        name: 'Correlation Window Size',\n        defaultValue: 30,\n        description: 'Pearson Correlation'\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tb2R1bGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNEM7QUFDVTtBQUUvQyxNQUFNRSxTQUFTLElBQUlGLHNEQUFXQSxDQUFDQywrREFBZ0JBLEVBQUVFLGVBQWUsQ0FBQ0M7SUFDdEVBLFFBQ0dDLGNBQWMsQ0FBQztRQUNkQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsY0FBYztRQUNkQyxhQUFhO0lBQ2Y7QUFDSixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW5lc2Jla2RlbWlyLWFuYWx5dGljcy1wYW5lbC8uL21vZHVsZS50cz9jMjE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhbmVsUGx1Z2luIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBDb3JyZWxhdGlvblBhbmVsIH0gZnJvbSAnLi9Db3JyZWxhdGlvblBhbmVsJztcblxuZXhwb3J0IGNvbnN0IHBsdWdpbiA9IG5ldyBQYW5lbFBsdWdpbihDb3JyZWxhdGlvblBhbmVsKS5zZXRQYW5lbE9wdGlvbnMoYnVpbGRlciA9PiB7XG4gIGJ1aWxkZXJcbiAgICAuYWRkTnVtYmVySW5wdXQoe1xuICAgICAgcGF0aDogJ3dpbmRvd1NpemUnLFxuICAgICAgbmFtZTogJ0NvcnJlbGF0aW9uIFdpbmRvdyBTaXplJyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogMzAsXG4gICAgICBkZXNjcmlwdGlvbjogJ1BlYXJzb24gQ29ycmVsYXRpb24nXG4gICAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJQYW5lbFBsdWdpbiIsIkNvcnJlbGF0aW9uUGFuZWwiLCJwbHVnaW4iLCJzZXRQYW5lbE9wdGlvbnMiLCJidWlsZGVyIiwiYWRkTnVtYmVySW5wdXQiLCJwYXRoIiwibmFtZSIsImRlZmF1bHRWYWx1ZSIsImRlc2NyaXB0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./module.ts\n\n}");

/***/ }),

/***/ "./node_modules/grafana-public-path.js":
/*!*********************************************!*\
  !*** ./node_modules/grafana-public-path.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var amd_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! amd-module */ \"amd-module\");\n/* harmony import */ var amd_module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(amd_module__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n__webpack_require__.p =\n  (amd_module__WEBPACK_IMPORTED_MODULE_0___default()) && (amd_module__WEBPACK_IMPORTED_MODULE_0___default().uri)\n    ? amd_module__WEBPACK_IMPORTED_MODULE_0___default().uri.slice(0, amd_module__WEBPACK_IMPORTED_MODULE_0___default().uri.lastIndexOf('/') + 1)\n    : 'public/plugins/enesbekdemir-analytics-panel/';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JhZmFuYS1wdWJsaWMtcGF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQ3VDOztBQUV2QyxxQkFBdUI7QUFDdkIsRUFBRSxtREFBYSxJQUFJLHVEQUFpQjtBQUNwQyxNQUFNLHFEQUFpQixVQUFVLHFEQUFpQjtBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VuZXNiZWtkZW1pci1hbmFseXRpY3MtcGFuZWwvLi9ub2RlX21vZHVsZXMvZ3JhZmFuYS1wdWJsaWMtcGF0aC5qcz85M2UzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IGFtZE1ldGFNb2R1bGUgZnJvbSAnYW1kLW1vZHVsZSc7XG5cbl9fd2VicGFja19wdWJsaWNfcGF0aF9fID1cbiAgYW1kTWV0YU1vZHVsZSAmJiBhbWRNZXRhTW9kdWxlLnVyaVxuICAgID8gYW1kTWV0YU1vZHVsZS51cmkuc2xpY2UoMCwgYW1kTWV0YU1vZHVsZS51cmkubGFzdEluZGV4T2YoJy8nKSArIDEpXG4gICAgOiAncHVibGljL3BsdWdpbnMvZW5lc2Jla2RlbWlyLWFuYWx5dGljcy1wYW5lbC8nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/grafana-public-path.js\n\n}");

/***/ }),

/***/ "./utils/correlation.ts":
/*!******************************!*\
  !*** ./utils/correlation.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeCointegrationZScore: () => (/* binding */ computeCointegrationZScore),\n/* harmony export */   slidingCorrelation: () => (/* binding */ slidingCorrelation),\n/* harmony export */   smoothSeries: () => (/* binding */ smoothSeries)\n/* harmony export */ });\nfunction slidingCorrelation(seriesA, seriesB, window) {\n    const safeWindow = Math.max(Math.floor(window), 1);\n    const length = Math.min(seriesA.length, seriesB.length);\n    const result = new Array(length);\n    for(let i = 0; i < length; i++){\n        if (i < safeWindow) {\n            result[i] = null;\n            continue;\n        }\n        const sliceA = seriesA.slice(i - safeWindow, i);\n        const sliceB = seriesB.slice(i - safeWindow, i);\n        const meanA = sliceA.reduce((a, b)=>a + b, 0) / safeWindow;\n        const meanB = sliceB.reduce((a, b)=>a + b, 0) / safeWindow;\n        const cov = sliceA.reduce((acc, aVal, idx)=>{\n            return acc + (aVal - meanA) * (sliceB[idx] - meanB);\n        }, 0) / safeWindow;\n        const stdA = Math.sqrt(sliceA.reduce((acc, aVal)=>acc + Math.pow(aVal - meanA, 2), 0) / safeWindow);\n        const stdB = Math.sqrt(sliceB.reduce((acc, bVal)=>acc + Math.pow(bVal - meanB, 2), 0) / safeWindow);\n        if (stdA === 0 || stdB === 0) {\n            result[i] = null;\n            continue;\n        }\n        result[i] = cov / (stdA * stdB);\n    }\n    return result;\n}\nfunction smoothSeries(values, radius) {\n    const windowRadius = Math.max(Math.floor(radius), 0);\n    if (windowRadius === 0) {\n        return values.slice();\n    }\n    return values.map((value, idx)=>{\n        if (value === null) {\n            return null;\n        }\n        let sum = 0;\n        let count = 0;\n        for(let offset = -windowRadius; offset <= windowRadius; offset++){\n            const neighborIndex = idx + offset;\n            if (neighborIndex < 0 || neighborIndex >= values.length) {\n                continue;\n            }\n            const neighborValue = values[neighborIndex];\n            if (neighborValue === null || !Number.isFinite(neighborValue)) {\n                continue;\n            }\n            sum += neighborValue;\n            count++;\n        }\n        return count > 0 ? sum / count : null;\n    });\n}\nconst isFiniteNumber = (value)=>typeof value === 'number' && Number.isFinite(value);\nconst performLinearRegression = (seriesA, seriesB)=>{\n    const length = Math.min(seriesA.length, seriesB.length);\n    const pairs = [];\n    for(let i = 0; i < length; i++){\n        const a = seriesA[i];\n        const b = seriesB[i];\n        if (!isFiniteNumber(a) || !isFiniteNumber(b)) {\n            continue;\n        }\n        pairs.push({\n            a,\n            b\n        });\n    }\n    if (pairs.length < 2) {\n        return {\n            alpha: 0,\n            beta: 0,\n            valid: false\n        };\n    }\n    const n = pairs.length;\n    let sumX = 0;\n    let sumY = 0;\n    let sumXY = 0;\n    let sumXX = 0;\n    for (const pair of pairs){\n        sumX += pair.b;\n        sumY += pair.a;\n        sumXY += pair.a * pair.b;\n        sumXX += pair.b * pair.b;\n    }\n    const denominator = n * sumXX - sumX * sumX;\n    if (denominator === 0) {\n        const meanY = sumY / n;\n        return {\n            alpha: meanY,\n            beta: 0,\n            valid: true\n        };\n    }\n    const beta = (n * sumXY - sumX * sumY) / denominator;\n    const alpha = (sumY - beta * sumX) / n;\n    return {\n        alpha,\n        beta,\n        valid: true\n    };\n};\nfunction computeCointegrationZScore(seriesA, seriesB, window) {\n    const length = Math.min(seriesA.length, seriesB.length);\n    const residuals = new Array(length).fill(null);\n    if (!length) {\n        return residuals;\n    }\n    const regression = performLinearRegression(seriesA, seriesB);\n    if (!regression.valid) {\n        return residuals;\n    }\n    for(let i = 0; i < length; i++){\n        const a = seriesA[i];\n        const b = seriesB[i];\n        if (!isFiniteNumber(a) || !isFiniteNumber(b)) {\n            continue;\n        }\n        residuals[i] = a - (regression.alpha + regression.beta * b);\n    }\n    const safeWindow = Math.max(Math.floor(window), 2);\n    const zscores = new Array(length).fill(null);\n    for(let i = 0; i < length; i++){\n        const currentResidual = residuals[i];\n        if (i < safeWindow - 1 || currentResidual === null) {\n            zscores[i] = null;\n            continue;\n        }\n        const start = Math.max(0, i - (safeWindow - 1));\n        const slice = [];\n        for(let idx = start; idx <= i; idx++){\n            const value = residuals[idx];\n            if (value === null || !Number.isFinite(value)) {\n                continue;\n            }\n            slice.push(value);\n        }\n        if (slice.length < 2) {\n            zscores[i] = null;\n            continue;\n        }\n        const mean = slice.reduce((acc, val)=>acc + val, 0) / slice.length;\n        const variance = slice.reduce((acc, val)=>acc + Math.pow(val - mean, 2), 0) / slice.length;\n        const std = Math.sqrt(variance);\n        if (!Number.isFinite(std) || std === 0) {\n            zscores[i] = null;\n            continue;\n        }\n        zscores[i] = (currentResidual - mean) / std;\n    }\n    return zscores;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxJQUFLUixDQUFBQSxhQUFhO1FBQzVDLE1BQU1VLFFBQWtCLEVBQUU7UUFDMUIsSUFBSyxJQUFJVSxNQUFNd0MsT0FBT3hDLE9BQU9aLEdBQUdZLE1BQU87WUFDckMsTUFBTVcsUUFBUXdCLFNBQVMsQ0FBQ25DLElBQUk7WUFDNUIsSUFBSVcsVUFBVSxRQUFRLENBQUNNLE9BQU9DLFFBQVEsQ0FBQ1AsUUFBUTtnQkFDN0M7WUFDRjtZQUNBckIsTUFBTWdDLElBQUksQ0FBQ1g7UUFDYjtRQUVBLElBQUlyQixNQUFNTixNQUFNLEdBQUcsR0FBRztZQUNwQnNELE9BQU8sQ0FBQ2xELEVBQUUsR0FBRztZQUNiO1FBQ0Y7UUFFQSxNQUFNcUQsT0FBT25ELE1BQU1HLE1BQU0sQ0FBQyxDQUFDSyxLQUFLNEMsTUFBUTVDLE1BQU00QyxLQUFLLEtBQUtwRCxNQUFNTixNQUFNO1FBQ3BFLE1BQU0yRCxXQUFXckQsTUFBTUcsTUFBTSxDQUFDLENBQUNLLEtBQUs0QyxNQUFRNUMsTUFBTWpCLEtBQUtzQixHQUFHLENBQUN1QyxNQUFNRCxNQUFNLElBQUksS0FBS25ELE1BQU1OLE1BQU07UUFDNUYsTUFBTTRELE1BQU0vRCxLQUFLcUIsSUFBSSxDQUFDeUM7UUFFdEIsSUFBSSxDQUFDMUIsT0FBT0MsUUFBUSxDQUFDMEIsUUFBUUEsUUFBUSxHQUFHO1lBQ3RDTixPQUFPLENBQUNsRCxFQUFFLEdBQUc7WUFDYjtRQUNGO1FBRUFrRCxPQUFPLENBQUNsRCxFQUFFLEdBQUcsQ0FBQ21ELGtCQUFrQkUsSUFBRyxJQUFLRztJQUMxQztJQUVBLE9BQU9OO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmVzYmVrZGVtaXItYW5hbHl0aWNzLXBhbmVsLy4vdXRpbHMvY29ycmVsYXRpb24udHM/YTJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gc2xpZGluZ0NvcnJlbGF0aW9uKFxuICBzZXJpZXNBOiBudW1iZXJbXSxcbiAgc2VyaWVzQjogbnVtYmVyW10sXG4gIHdpbmRvdzogbnVtYmVyXG4pOiBBcnJheTxudW1iZXIgfCBudWxsPiB7XG4gIGNvbnN0IHNhZmVXaW5kb3cgPSBNYXRoLm1heChNYXRoLmZsb29yKHdpbmRvdyksIDEpO1xuICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihzZXJpZXNBLmxlbmd0aCwgc2VyaWVzQi5sZW5ndGgpO1xuICBjb25zdCByZXN1bHQ6IEFycmF5PG51bWJlciB8IG51bGw+ID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChpIDwgc2FmZVdpbmRvdykge1xuICAgICAgcmVzdWx0W2ldID0gbnVsbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHNsaWNlQSA9IHNlcmllc0Euc2xpY2UoaSAtIHNhZmVXaW5kb3csIGkpO1xuICAgIGNvbnN0IHNsaWNlQiA9IHNlcmllc0Iuc2xpY2UoaSAtIHNhZmVXaW5kb3csIGkpO1xuXG4gICAgY29uc3QgbWVhbkEgPSBzbGljZUEucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBzYWZlV2luZG93O1xuICAgIGNvbnN0IG1lYW5CID0gc2xpY2VCLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gc2FmZVdpbmRvdztcblxuICAgIGNvbnN0IGNvdiA9IHNsaWNlQS5yZWR1Y2UoKGFjYywgYVZhbCwgaWR4KSA9PiB7XG4gICAgICByZXR1cm4gYWNjICsgKGFWYWwgLSBtZWFuQSkgKiAoc2xpY2VCW2lkeF0gLSBtZWFuQik7XG4gICAgfSwgMCkgLyBzYWZlV2luZG93O1xuXG4gICAgY29uc3Qgc3RkQSA9IE1hdGguc3FydChcbiAgICAgIHNsaWNlQS5yZWR1Y2UoKGFjYywgYVZhbCkgPT4gYWNjICsgTWF0aC5wb3coYVZhbCAtIG1lYW5BLCAyKSwgMCkgLyBzYWZlV2luZG93XG4gICAgKTtcblxuICAgIGNvbnN0IHN0ZEIgPSBNYXRoLnNxcnQoXG4gICAgICBzbGljZUIucmVkdWNlKChhY2MsIGJWYWwpID0+IGFjYyArIE1hdGgucG93KGJWYWwgLSBtZWFuQiwgMiksIDApIC8gc2FmZVdpbmRvd1xuICAgICk7XG5cbiAgICBpZiAoc3RkQSA9PT0gMCB8fCBzdGRCID09PSAwKSB7XG4gICAgICByZXN1bHRbaV0gPSBudWxsO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0W2ldID0gY292IC8gKHN0ZEEgKiBzdGRCKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbW9vdGhTZXJpZXModmFsdWVzOiBBcnJheTxudW1iZXIgfCBudWxsPiwgcmFkaXVzOiBudW1iZXIpOiBBcnJheTxudW1iZXIgfCBudWxsPiB7XG4gIGNvbnN0IHdpbmRvd1JhZGl1cyA9IE1hdGgubWF4KE1hdGguZmxvb3IocmFkaXVzKSwgMCk7XG4gIGlmICh3aW5kb3dSYWRpdXMgPT09IDApIHtcbiAgICByZXR1cm4gdmFsdWVzLnNsaWNlKCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzLm1hcCgodmFsdWUsIGlkeCkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAobGV0IG9mZnNldCA9IC13aW5kb3dSYWRpdXM7IG9mZnNldCA8PSB3aW5kb3dSYWRpdXM7IG9mZnNldCsrKSB7XG4gICAgICBjb25zdCBuZWlnaGJvckluZGV4ID0gaWR4ICsgb2Zmc2V0O1xuICAgICAgaWYgKG5laWdoYm9ySW5kZXggPCAwIHx8IG5laWdoYm9ySW5kZXggPj0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmVpZ2hib3JWYWx1ZSA9IHZhbHVlc1tuZWlnaGJvckluZGV4XTtcbiAgICAgIGlmIChuZWlnaGJvclZhbHVlID09PSBudWxsIHx8ICFOdW1iZXIuaXNGaW5pdGUobmVpZ2hib3JWYWx1ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN1bSArPSBuZWlnaGJvclZhbHVlO1xuICAgICAgY291bnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gY291bnQgPiAwID8gc3VtIC8gY291bnQgOiBudWxsO1xuICB9KTtcbn1cblxuY29uc3QgaXNGaW5pdGVOdW1iZXIgPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpO1xuXG5jb25zdCBwZXJmb3JtTGluZWFyUmVncmVzc2lvbiA9IChzZXJpZXNBOiBudW1iZXJbXSwgc2VyaWVzQjogbnVtYmVyW10pID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oc2VyaWVzQS5sZW5ndGgsIHNlcmllc0IubGVuZ3RoKTtcbiAgY29uc3QgcGFpcnM6IEFycmF5PHsgYTogbnVtYmVyOyBiOiBudW1iZXIgfT4gPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYSA9IHNlcmllc0FbaV07XG4gICAgY29uc3QgYiA9IHNlcmllc0JbaV07XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihhKSB8fCAhaXNGaW5pdGVOdW1iZXIoYikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwYWlycy5wdXNoKHsgYSwgYiB9KTtcbiAgfVxuXG4gIGlmIChwYWlycy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHsgYWxwaGE6IDAsIGJldGE6IDAsIHZhbGlkOiBmYWxzZSB9IGFzIGNvbnN0O1xuICB9XG5cbiAgY29uc3QgbiA9IHBhaXJzLmxlbmd0aDtcbiAgbGV0IHN1bVggPSAwO1xuICBsZXQgc3VtWSA9IDA7XG4gIGxldCBzdW1YWSA9IDA7XG4gIGxldCBzdW1YWCA9IDA7XG5cbiAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgc3VtWCArPSBwYWlyLmI7XG4gICAgc3VtWSArPSBwYWlyLmE7XG4gICAgc3VtWFkgKz0gcGFpci5hICogcGFpci5iO1xuICAgIHN1bVhYICs9IHBhaXIuYiAqIHBhaXIuYjtcbiAgfVxuXG4gIGNvbnN0IGRlbm9taW5hdG9yID0gbiAqIHN1bVhYIC0gc3VtWCAqIHN1bVg7XG4gIGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuICAgIGNvbnN0IG1lYW5ZID0gc3VtWSAvIG47XG4gICAgcmV0dXJuIHsgYWxwaGE6IG1lYW5ZLCBiZXRhOiAwLCB2YWxpZDogdHJ1ZSB9IGFzIGNvbnN0O1xuICB9XG5cbiAgY29uc3QgYmV0YSA9IChuICogc3VtWFkgLSBzdW1YICogc3VtWSkgLyBkZW5vbWluYXRvcjtcbiAgY29uc3QgYWxwaGEgPSAoc3VtWSAtIGJldGEgKiBzdW1YKSAvIG47XG4gIHJldHVybiB7IGFscGhhLCBiZXRhLCB2YWxpZDogdHJ1ZSB9IGFzIGNvbnN0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVDb2ludGVncmF0aW9uWlNjb3JlKFxuICBzZXJpZXNBOiBudW1iZXJbXSxcbiAgc2VyaWVzQjogbnVtYmVyW10sXG4gIHdpbmRvdzogbnVtYmVyXG4pOiBBcnJheTxudW1iZXIgfCBudWxsPiB7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKHNlcmllc0EubGVuZ3RoLCBzZXJpZXNCLmxlbmd0aCk7XG4gIGNvbnN0IHJlc2lkdWFsczogQXJyYXk8bnVtYmVyIHwgbnVsbD4gPSBuZXcgQXJyYXkobGVuZ3RoKS5maWxsKG51bGwpO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiByZXNpZHVhbHM7XG4gIH1cblxuICBjb25zdCByZWdyZXNzaW9uID0gcGVyZm9ybUxpbmVhclJlZ3Jlc3Npb24oc2VyaWVzQSwgc2VyaWVzQik7XG4gIGlmICghcmVncmVzc2lvbi52YWxpZCkge1xuICAgIHJldHVybiByZXNpZHVhbHM7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYSA9IHNlcmllc0FbaV07XG4gICAgY29uc3QgYiA9IHNlcmllc0JbaV07XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihhKSB8fCAhaXNGaW5pdGVOdW1iZXIoYikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXNpZHVhbHNbaV0gPSBhIC0gKHJlZ3Jlc3Npb24uYWxwaGEgKyByZWdyZXNzaW9uLmJldGEgKiBiKTtcbiAgfVxuXG4gIGNvbnN0IHNhZmVXaW5kb3cgPSBNYXRoLm1heChNYXRoLmZsb29yKHdpbmRvdyksIDIpO1xuICBjb25zdCB6c2NvcmVzOiBBcnJheTxudW1iZXIgfCBudWxsPiA9IG5ldyBBcnJheShsZW5ndGgpLmZpbGwobnVsbCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRSZXNpZHVhbCA9IHJlc2lkdWFsc1tpXTtcbiAgICBpZiAoaSA8IHNhZmVXaW5kb3cgLSAxIHx8IGN1cnJlbnRSZXNpZHVhbCA9PT0gbnVsbCkge1xuICAgICAgenNjb3Jlc1tpXSA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGkgLSAoc2FmZVdpbmRvdyAtIDEpKTtcbiAgICBjb25zdCBzbGljZTogbnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGxldCBpZHggPSBzdGFydDsgaWR4IDw9IGk7IGlkeCsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHJlc2lkdWFsc1tpZHhdO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8ICFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc2xpY2UucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHNsaWNlLmxlbmd0aCA8IDIpIHtcbiAgICAgIHpzY29yZXNbaV0gPSBudWxsO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgbWVhbiA9IHNsaWNlLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCkgLyBzbGljZS5sZW5ndGg7XG4gICAgY29uc3QgdmFyaWFuY2UgPSBzbGljZS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyBNYXRoLnBvdyh2YWwgLSBtZWFuLCAyKSwgMCkgLyBzbGljZS5sZW5ndGg7XG4gICAgY29uc3Qgc3RkID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHN0ZCkgfHwgc3RkID09PSAwKSB7XG4gICAgICB6c2NvcmVzW2ldID0gbnVsbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHpzY29yZXNbaV0gPSAoY3VycmVudFJlc2lkdWFsIC0gbWVhbikgLyBzdGQ7XG4gIH1cblxuICByZXR1cm4genNjb3Jlcztcbn1cbiJdLCJuYW1lcyI6WyJzbGlkaW5nQ29ycmVsYXRpb24iLCJzZXJpZXNBIiwic2VyaWVzQiIsIndpbmRvdyIsInNhZmVXaW5kb3ciLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJsZW5ndGgiLCJtaW4iLCJyZXN1bHQiLCJBcnJheSIsImkiLCJzbGljZUEiLCJzbGljZSIsInNsaWNlQiIsIm1lYW5BIiwicmVkdWNlIiwiYSIsImIiLCJtZWFuQiIsImNvdiIsImFjYyIsImFWYWwiLCJpZHgiLCJzdGRBIiwic3FydCIsInBvdyIsInN0ZEIiLCJiVmFsIiwic21vb3RoU2VyaWVzIiwidmFsdWVzIiwicmFkaXVzIiwid2luZG93UmFkaXVzIiwibWFwIiwidmFsdWUiLCJzdW0iLCJjb3VudCIsIm9mZnNldCIsIm5laWdoYm9ySW5kZXgiLCJuZWlnaGJvclZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpc0Zpbml0ZU51bWJlciIsInBlcmZvcm1MaW5lYXJSZWdyZXNzaW9uIiwicGFpcnMiLCJwdXNoIiwiYWxwaGEiLCJiZXRhIiwidmFsaWQiLCJuIiwic3VtWCIsInN1bVkiLCJzdW1YWSIsInN1bVhYIiwicGFpciIsImRlbm9taW5hdG9yIiwibWVhblkiLCJjb21wdXRlQ29pbnRlZ3JhdGlvblpTY29yZSIsInJlc2lkdWFscyIsImZpbGwiLCJyZWdyZXNzaW9uIiwienNjb3JlcyIsImN1cnJlbnRSZXNpZHVhbCIsInN0YXJ0IiwibWVhbiIsInZhbCIsInZhcmlhbmNlIiwic3RkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/correlation.ts\n\n}");

/***/ }),

/***/ "@grafana/data":
/*!********************************!*\
  !*** external "@grafana/data" ***!
  \********************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__grafana_data__;

/***/ }),

/***/ "amd-module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_amd_module__;

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "public/plugins/enesbekdemir-analytics-panel/";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./module.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});;